## Actors: A Model of Concurrent Computation in Distributed Systems. 

Gul Agha (1985)

<br>

## Chapter 1. Introduction

모든 언어의 목적은 의사소통에 있으며, 프로그래밍 언어의 목적은 컴퓨터에게 수행해야 할 동작을 전달하는 것이다. 프로그래밍 언어 설계에서는 보통 두 가지 목표 중 하나를 강조하게 된다. 바로 **실행 효율성(efficiency)** 과 **표현력(expressiveness)** 이다.
여기서 “효율성”이란, 프로그램에 포함된 동작을 컴퓨터가 얼마나 빠르게 수행할 수 있는지를 의미한다. 엄밀한 의미에서 가장 효율적인 언어는 컴퓨터에게 직접적으로 수행할 명령을 전달하는 언어, 즉 기계어(machine language)라고 할 수 있다.¹
반면, “표현력”이란 프로그램의 의미를 쉽게 이해하고, 그것이 올바르게 동작함을 쉽게 보여줄 수 있는 능력을 말한다. 합리적인 동작을 가장 간결하게 표현할 수 있을수록, 그 언어는 표현력이 높다고 할 수 있다.

¹ 물론, 각 프로세서는 고유의 기계어를 가지며, 어떤 기계어는 다른 것보다 “본질적으로” 더 효율적일 수도 있다.

실행 효율성만을 극대화하는 프로그래밍 언어가 반드시 최상의 성능을 보장하는 프로그램을 만들게 하는 것은 아니다. 
이는 프로그래머가 “무엇을 표현할지”보다 “어떻게 표현할지”에 더 많은 시간을 소비할 수 있기 때문이다. 
실제 성능 향상은 동일한 결과를 더 낮은 계산 복잡도로 수행할 수 있는 방법을 찾음으로써 이루어진다.
대체로 새로운 프로그래밍 언어들이 등장한 이유는, 더 복잡한 동작을 더 쉽게 표현하기 위한 것이다. 
초기에는 컴퓨터가 주로 잘 정의된 수학 함수를 계산하는 데 사용되었지만, 현대 컴퓨터는 훨씬 다양한 작업을 수행한다. 
예를 들어, 정보 저장, 정렬 및 탐색, 불완전하게 정의된 영역에 대한 실시간 탐색 등이 점점 더 중요해지고 있다. 
자동차 등록 정보 데이터베이스, 화성 표면을 탐사하는 자율주행 차량 같은 인공지능 응용도 대표적인 예다. 
이처럼 컴퓨터 프로그램의 사용 범위가 넓어지면서, 우리가 표현하고자 하는 동작의 종류도 더욱 일반적이고 복잡해졌다.

새로운 언어들이 일반적으로 표현력을 효율성보다 중시해 왔음에도 불구하고, 우리는 점점 더 복잡한 문제를 컴퓨터로 해결할 수 있게 되었다. 
이 놀라운 경향은 더 크고 더 빠른 프로세서를 만드는 기술 덕분에 가능했다. 그러나 이제는 개별 프로세서의 크기나 속도를 더 늘리는 것이 한계에 다다랐을 가능성이 있다. 
실제로, 많은 수의 더 작은 프로세서를 협력적으로 사용할 수 있다면 훨씬 더 비용 효율적일 것이다. 이는 곧, **병렬성(parallelism)** 을 활용해야 한다는 뜻이다.

이제 이 논문의 핵심 주제, 즉 동시성을 위한 적합한 언어의 개발로 넘어간다. 여기서 **동시성(concurrency)** 이란 여러 동작을 잠재적으로 병렬로 실행하는 것을 의미한다. 
사실, 동시성 자체는 새로운 개념이 아니다. 타임셰어링(time-sharing)으로 인한 소프트웨어 혁명에서도 동시성은 이미 활용되어 왔다.
하지만 운영체제의 전통적인 문제와 우리가 지향하는 동시성 활용 간에는 중요한 차이가 있다. 운영체제에서는 여러 사용자 프로세스가 서로 간섭하지 않도록 하는 것이 올바른 동작의 핵심이다.
그러나 우리가 풀고자 하는 문제는 이와 정반대다. 여러 개의 프로세스가 유의미하게 협력하여 함께 동작하도록 하고자 한다.

여기서 “프로세서” 대신 “프로세스”라는 용어를 사용하는 데 주목하자. 프로세서는 물리적인 장치인 반면, 프로세스는 추상적인 계산 단위다. 
운영체제 이론으로부터 우리는, 여러 프로세스를 동시 실행함으로써 하나의 프로세서를 더 효과적으로 사용할 수 있음을 알고 있다. 
물론, 이러한 프로세서의 실제 활용은 언어를 지원하는 네트워크 아키텍처에 의존한다. 그러나 우리는 이 구현의 구체성에 관계없이 동시성을 모델링하는 방식 자체에 관심을 가진다.
즉, 프로세스들이 네트워크 상에 분산되어 병렬로 실행되더라도, 프로그래밍 언어가 동시성을 지원하지 않으면 이러한 아키텍처는 단일 프로세서보다 나은 성능을 내지 못한다.

사실, 우리는 특정 프로그래밍 언어 자체보다는 동시성 언어의 구조를 뒷받침하는 메타 언어적(meta-linguistic) 개념에 더 관심이 있다. 
언어의 작동 의미론(operational semantics)은 추상 기계(혹은 액터 모델에서는 기계 시스템)에 대한 명령어 집합을 정의한다. 
우리의 관심사는 이러한 계산 모델의 특성, 특히 표현력과 효율성이 동시성에서 어떻게 발현되는가에 있다.

동시성 이론이 필요한 내재적 이유도 존재한다. 대표적인 예는 지능적 시스템과 공동체를 이해하는 데 동시성이 필수적이라는 점이다. 
예를 들어, 학습하거나 적응하는 자연 시스템은 모두 본질적으로 병렬적이며, 그 규모는 매우 크다. 
동물의 뇌, 생태계, 사회 조직(인간이든 비인간이든)은 모두 동시성을 활용하는 분산 시스템이다. 
더 나아가, 적응과 자연 선택의 근간인 유전 알고리즘(genetic algorithm) 역시 본질적으로 병렬적이다 [Holland 75]. 
이들 시스템이 보여주는 성공은 동시 처리(concurrent processing)의 함의를 연구할 강력한 동기를 제공한다.

이 장의 나머지 부분은 논문 전체의 개요를 제공한다.

**2장**에서는 모든 동시성 모델에서 고려해야 할 일반적인 설계 결정을 살펴본다.

**3장**에서는 액터의 동작을 설명하고, 액터의 구체적인 예시를 다룰 수 있는 간단한 액터 언어를 정의한다.

**4장**에서는 액터 언어를 더 표현력 있게 만들어주는 고수준 구성 요소들을 정의하고, 추상화 메커니즘도 제공한다.
이러한 구성 요소들은 기본 액터 구성 요소를 기반으로 정의되며, 액터 형식주의의 일부로 간주되지 않는다. 또한 표현 언어(expression language)를 정의하고, 다양한 평가 전략도 논의한다.

**5장**에서는 액터 시스템 구성에 대한 전이 관계를 명시함으로써 액터 언어의 작동 의미론을 정의한다. 메시지 전달 보장을 위해 두 번째 전이 시스템도 정의하며, 최소 구성 요소들이 어떻게 작동 의미론적으로 정의될 수 있는지를 보여준다.

**6장**에서는 관련 모델들에서 제기된 문제들을 다룬다. 특히, 발산(divergence)과 교착 상태(deadlock)와 같은 병렬 시스템의 병적 동작을 액터 모델이 어떻게 다루는지를 살펴본다. 
액터의 비동기, 버퍼링된 통신 방식은 의미론적 교착 탐지를 가능하게 하며, 전통적인 의미의 교착 상태는 액터 시스템에서는 존재하지 않는다. 또한 데이터플로우 모델과 액터 모델 간의 유사성도 논의한다.

**7장**에서는 추상화(abstraction)와 구성 가능성(compositionality) 문제를 다룬다. 특히 개방형 시스템(open system) 개념을 소개하며, [Brock and Ackerman 77]에서 언급한 이력 관계(history relation)의 불충분성을 설명한다. 
적절한 추상화 수준은 서로 동등한 시스템을 의미론적으로 동일하게 다루고, 동등하지 않은 시스템을 구분할 수 있게 한다. 우리는 액터의 조합을 어떻게 모델링할 수 있는지도 논의한다.

**마지막 장(8장)** 에서는 본 논문의 함의들을 요약한다.

부록에서는 Milner의 도구를 이용하여 액터 시스템을 비동기 통신 트리(Asynchronous Communication Trees)로 표현하는 추상적 표현을 정의하며, 이는 액터 계산을 시각화하는 데 유용하다.

<br>

**기여 (Contributions)** <br>
이 논문의 구체적인 기여는 다음과 같다:
- 다양한 동시성 모델에 대한 비판적 개관
- 액터 모델의 간단한 개요와 액터 언어를 위한 최소 구성 요소 정의
- 액터 시스템을 위한 전이 시스템과 작동 의미론 제시
- 분산 컴퓨팅의 문제를 다룰 수 있는 패러다임 제안 (개방형 시스템에 적합)
- 불필요한 세부사항으로부터의 추상화와 구성 가능성을 지원하는 모델 제시

<br>
<br>

## Chapter 2. General Design Decisions

동시 계산(concurrent computation)에 대한 여러 가지 근본적으로 다른 모델들이 제안되어 왔다. 
이 장에서는 각 모델의 기본 개념들을 검토한다. 우리의 관심은 이들 모델의 기본 구성요소(primitive)를 비교하고 대조함으로써 그 일반성을 평가하는 데 있다. 
특히 관심을 두는 부분은 대규모 병렬 아키텍처를 얼마나 쉽게 활용할 수 있는가 하는 점이다. 어떤 동시 계산 모델에도 필수적인 설계 결정은 다음과 같다:

- 글로벌 동기화 vs 비동기 요소
- 계산 요소 간 상호작용 방식
- 공정성의 정도
- 재구성 가능성 및 확장성

이 목록이 전부는 아니며, 우리가 가장 중요하다고 생각하는 측면들을 나타낸다. 
각 모델을 기반으로 한 언어 명세에 있어서의 언어적 문제와 같은 다른 이슈들도 있지만, 현재 논의에서는 그러한 세부 사항은 생략한다. 이어지는 섹션에서는 위의 설계 이슈들을 각각 논의한다.

#### 2.1 The Nature of Computing Elements

계산을 수행하는 요소는 추상적 의미에서 어떤 형태의 함수라고 볼 수 있다. 
그러나 이들 요소의 동작을 정의하는 함수의 정의역(domain)과 공역(range)은 모델마다 크게 다르다. 중요한 세부 사항들을 생략하고, 우리는 세 가지 주요한 계산 요소를 다음과 같이 구분한다:

- 순차적 프로세스(Sequential Processes)
- 데이터 값을 변형하는 함수(Function Transformations)
- 액터(Actors)

#### 2.1.1 순차적 프로세스
순차적 프로세스는 일련의 상태 변환을 수행한다. 여기서 상태(state)란 위치(location)에서 값(value)으로의 매핑이다. 이 상태 변환은 특정 입력에 의존하며 출력도 생성할 수 있다. 
이와 같은 입력과 출력의 고려는 순차적 프로세스 시스템의 의미론을 어렵게 만드는 주요 원인 중 하나이며, 특히 입력이 도착하지 않을 때 발생하는 교착(deadlock) 상태를 명시적으로 고려해야 한다 [Brookes 83].
순차적 프로세스는 그 자체로 순차적이지만, 서로 병렬로 실행될 수 있다. 이러한 프로세스들은 일반적으로 순차 프로그래밍에서의 ALGOL 계열 절차(procedures)에서 영감을 받았다. 순차적 프로세스를 기반으로 한 시스템의 예로는 다음과 같다:
Concurrent Pascal [Brinch Hansen 77], Communicating Sequential Processes [Hoare 77], 공유 변수 모델 (Shared Variables) [Lynch and Fischer 81]

#### 2.1.2 데이터 값을 변형하는 함수
두 번째 유형의 계산 요소는 저장소 없이 직접 데이터를 처리하는 함수이다. 이러한 함수형 모델은 람다 계산(λ-calculus) 기반 언어들, 예컨대 Pure Lisp [McCarthy 59]에서 유래했다. 
함수형 모델을 사용하는 동시 시스템의 예로는 다음과 같은 것들이 있다: 데이터플로우(dataflow) [Agerwala and Arvind 82], 병렬 프로세스 네트워크 [Kahn and MacQueen 77]

데이터플로우 아키텍처에서는 데이터 스트림이 함수형 에이전트를 통과한다 [Weng 75]. 동시성은 함수의 인자를 병렬로 평가할 수 있다는 사실에서 비롯된다.
가장 단순한 함수형 시스템 모델은 인자를 값으로 평가한 후 결과를 하나의 값으로 반환하는 불확정 응용 시스템(indeterminate applicative system)이다. 
이런 시스템에서는 인자들을 평가하고 전달하는 과정에서 계산이 “안쪽으로 모이는(fan-in)” 구조를 가진다.

Figure 2.1은 이러한 시스템에서의 병렬 평가 예시를 보여준다. <br>
<img width="544" height="435" alt="image" src="https://github.com/user-attachments/assets/ce7c74ff-bcd8-46e3-bbe1-2bd21dde4f35" />
<br>

함수형 요소는 여러 인자를 입력으로 받을 수 있지만, 주어진 인자에 대해서는 단 하나의 결과만 출력할 수 있다. 그러나 같은 출력 값을 여러 계산 요소로 전달할 수는 있다.
문제는, 함수는 이력(history)에 민감하지 않다는 점이다 [Backus 78]. 이는 시간에 따라 동작이 변할 수 있는 시스템을 모델링하는 데 어려움을 준다. 
예를 들어, 회전식 문(turnstile)의 행동을 생각해보자. 이 문은 통과한 사람 수를 카운트하며, 매번 회전할 때마다 새로운 숫자를 반환한다. 이는 단순히 “회전” 메시지의 함수로 설명될 수 없고, 이전 상태에 따라 달라지는 이력 의존적인 동작이다.

이러한 문제는 피드백과 순환 구조(cyclic structure)를 이용하여 해결할 수 있다. Figure 2.2는 이를 나타내며, 회전식 문을 두 개의 입력 — “회전” 메시지와 정수 n — 의 함수로 표현하고, n+1을 결과로 생성한다. 링크는 FIFO 채널처럼 작동하여 다음 값을 버퍼링한다.
<img width="564" height="256" alt="image" src="https://github.com/user-attachments/assets/1e7eb84f-508f-42c9-98ba-c744791970bd" />
<br>

#### 2.1.3 액터(Actors)
액터(actor)는 각 입력 메시지를 다음 세 가지로 매핑하는 계산 에이전트이다:

1. 다른 액터들에게 보낼 유한한 메시지 집합
2. 다음 메시지를 처리할 때 사용할 새로운 행동(behavior)
3. 새로 생성된 액터들의 유한 집합

여기서 몇 가지 중요한 점이 있다: 액터의 행동은 이력(history)에 민감할 수 있다.
액터가 수행하는 작업에는 순차성이 전제되지 않는다. 모든 동작은 현재 행동과 입력 메시지의 함수로 표현된다.
액터 생성(actor creation) 은 계산 모델의 핵심이며, 외부적인 기능이 아니다.
액터의 개념은 SIMULA 언어에서 제시된 객체(object) 개념의 발전된 형태이다 [Dahl et al. 70]. 여기서 객체는 데이터를 그 데이터에 작용하는 연산 및 절차들과 함께 하나의 단위로 묶은 것이다.

액터는 순차적 프로세스나 함수형 시스템보다 더 강력한 계산 모델이다. 
다시 말해, 함수형 시스템이나 순차적 프로세스를 액터 시스템으로 표현하는 것은 가능하지만, 
액터 시스템을 이들로 완전히 표현하는 것은 불가능하다. 이는 액터가 다른 액터를 생성할 수 있는 반면, 함수형 모델이나 순차적 프로세스 모델은 새로운 함수나 프로세스를 생성할 수 없기 때문이다.
순차 계산 패러다임에서는 이 차이가 별로 중요하지 않을 수 있다. 하지만 병렬 시스템의 맥락에서는, 계산이 진행됨에 따라 계산을 얼마나 분산(distribute) 시킬 수 있는지가 중요한 요소이다. 
액터를 새로 생성할 수 있다는 것은 계산이 진화함에 따라 분산성을 동적으로 확장할 수 있는 능력을 보장한다.

<br>
<br>

## Chapter 3. Computation In Actor Systems

이 장에서는 액터 패러다임에서의 계산 구조를 살펴본다. 이 논의는 기술적인 세부 사항은 다음 장으로 미루고, 비공식적이고 직관적인 방식으로 진행된다. 
이 장의 구성은 다음과 같다. 첫 번째 절에서는 액터와 통신에 대해 설명한다. 두 번째 절에서는 최소한의 액터 언어를 정의하는 데 충분한 구성 요소들을 개요적으로 제시한다. 
구조화된 "의사 코드(pseudo-code)"만을 사용하여 이 구성 요소들을 활용한 액터 프로그램의 예제를 제공한다. 
마지막 절에서는 두 가지 간단한 액터 언어인 SAL과 Act의 커널(kernel)을 정의하고, 각 언어로 작성된 프로그램 예제를 제시한다. 
SAL은 알골(Algol)-유사 문법을 따르며, Act는 리스프(Lisp)-유사 문법을 따른다. 다음 장에서는 새로운 언어적 구성 요소들을 정의할 것이지만, 이러한 구성 요소들은 기본이 되는 것은 아니며,
최소한의 액터 언어를 이용해 정의될 수 있다. 이처럼 최소 언어에 대한 확장은 기본적인 액터 구성 요소들의 강력함을 보여준다.

#### 3.1 액터 시스템 정의하기
액터 시스템에서의 계산은 시스템에 보내진 **통신(communication)** 에 대한 응답으로 발생한다. 통신은 작업(task) 안에 포함되어 있다. 
계산이 진행되면서, 액터 시스템은 현재 처리 중인 작업들에 의해 새로운 작업과 새로운 액터가 생성되며 점차 확장된다. 
이미 처리된 작업들과 더 이상 “유용하지 않은” 액터들(이 개념은 나중에 좀 더 정밀하게 정의된다)은 시스템에서 제거(즉, 가비지 컬렉션)되어도 이후의 시스템 동작에는 영향을 주지 않는다.¹

¹ 여기서 "가비지(garbage)"가 있는 시스템과 없는 시스템의 의미론적 동등성을 말한다. 물론 시스템 성능 측면은 별개의 문제이다.

액터 시스템의 구성(configuration)은 그 안에 포함된 액터들과 아직 처리되지 않은 작업들의 집합에 의해 정의된다.

#### 3.1.1 작업(Tasks)
조금 단순화해서 말하자면, 액터 시스템 내에서 처리되지 않은 작업들은 시스템 계산의 원동력이라고 할 수 있다. 하나의 작업은 다음 세 요소로 구성된 3-튜플로 표현된다:

1. 태그(tag) – 시스템 내 다른 작업들과 구별할 수 있는 식별자
2. 대상(target) – 통신이 전달될 메일 주소(mail address)
3. 통신(communication) – 해당 작업을 처리할 때, 대상 액터에게 제공될 정보

단순화를 위해, 통신은 값들의 튜플로 간주한다. 이 값들은 액터의 메일 주소일 수도 있고, 정수, 문자열 등이 될 수도 있다. 적절한 형식 시스템(type discipline)을 이 값들에 적용할 수도 있다.
이 외에도 다양한 모델이 존재한다. 아마도 가장 흥미롭고, 가장 구성의 일관성(uniformity)이 높은 모델은 통신 자체가 액터가 되는 모델일 것이다.²

² 액터의 동작은 자신이 알고 있는 다른 액터(즉, 자신의 지인 acquaintance)들에게 통신을 보내는 것이다. 이들 액터도 마찬가지로 통신을 보내며, 결국 이 통신은 숫자나 원시 연산자 같은 사전 정의된 기본 액터에 도달한다 (4.4절 참조). 
더 일반화된 "액터의 우주(universe of actors)" 모델에서는, 작업(task) 자체도 세 구성 요소(위의 3-튜플)를 지인으로 갖는 액터가 된다.

이러한 모델에서는 통신도 통신을 받을 수 있는 액터가 된다. 예를 들어, 어떤 통신 k1이 스스로를 출력하게 하려면, k1에게 자신을 출력하라는 내용을 담은 통신 k2를 보낼 수 있다.
통신이 액터인 모델은 future(미래값)을 활용한 call-by-need (필요 시 계산) 기법을 단순하고 효과적으로 구현할 수 있다. 미래값은 자신에게 "자신을 계산하라"는 통신을 받을 수 있는 통신이다.
그러나 통신을 액터로 모델링하는 경우 액터의 의미론적 이론은 훨씬 복잡해지므로, 여기서는 그러한 모델은 다루지 않는다.³

³ "액터의 우주(universe of actors)" 모델에 대한 논의는 §4.4를 참고하라.

대상(target)은 유효한 메일 주소여야 한다. 다시 말해, 어떤 액터가 타깃에게 통신을 보내기 전에, 해당 타깃이 유효한 메일 주소라는 것을 알아야 한다 [Hewitt and Baker 77]. 
액터 a가 통신 k를 수락했을 때, 통신을 보낼 수 있는 타깃을 인식할 수 있는 방식은 세 가지이다:

- a가 통신 k를 수락하기 전부터 해당 타깃을 알고 있었던 경우
- a가 통신 k를 수락할 때, 그 통신 안에 타깃 정보가 포함되어 있었기 때문에 타깃을 알게 된 경우
- a가 통신 k를 수락한 결과로 새롭게 생성된 액터의 메일 주소가 타깃이 되는 경우

태그(tag)는 동일한 타깃과 동일한 통신을 포함할 수 있는 작업들 사이를 구분함으로써, 각 작업을 고유하게 식별하는 데 도움을 준다. 우리는 이후 액터 시스템의 작동 의미론(operational semantics)을 정의할 때 각 태그의 고유성을 활용할 것이다. 
여기서 중요한 점은, 태그의 구체적인 표현 방식은 다소 임의적이라는 점이다. 태그는 작업을 추적하기 위한 도구로 지정되는 것이며, 작업 자체는 실존적으로 구분되는 개체들이다.

태그를 표현하는 방법은 여러 가지가 있습니다. 한 가지 표현 방식은 음이 아닌 정수들을 $`\cdot`$(periods)으로 구분한 문자열 형태이다. 
이 표현을 사용할 경우, 작업 t에 대한 태그가 w라면, 어떤 음이 아닌 정수 n을 붙여 w.n이라는 형태로 태그를 생성하면, 이는 t의 처리 결과로 생성된 작업에 대한 태그가 될 수 있다.

이와 같이, 작업에 고유하게 연관된 태그 집합으로 시작하면, 항상 모든 작업이 서로 구별되는 태그를 갖도록 보장할 수 있다 (동일한 통신에 대해 동일한 액터가 생성하는 각 작업마다 마지막에 붙이는 숫자를 서로 다르게 한다는 제약을 둠으로써).
단, 주어진 시스템 내에서 존재할 수 있는 작업 수는 유한하다는 점에 유의해야 한다.

#### 3.1.2 액터의 동작 (The Behavior of an Actor)
앞서 논의한 것처럼, 액터 시스템에서 모든 계산은 통신을 처리한 결과로 발생한다. 이는 데이터플로우(dataflow) 같은 데이터 기반 시스템과 어느 정도 유사하며, 종료되거나 지속적으로 "활성" 상태인 프로세스 기반 시스템과는 대조된다. 
액터는 어떤 통신을 포함한 작업을 처리할 때 그 통신을 "수락(accept)"한다고 말한다. 액터는 오직 자신의 메일 주소와 일치하는 대상의 작업만 처리할 수 있다. 액터가 통신을 수락하면, 새로운 액터나 작업을 생성할 수 있으며, 반드시 대체 행동(replacement behavior) 또한 계산해야 한다.

각 액터에 대해, 해당 액터로 전송된 통신의 도착 순서는 선형 순서(linear order) 를 가진다. 특히, 이는 여러 통신이 거의 동시에 도착할 경우를 고려할 때, 메일 시스템이 통신을 적절히 버퍼링(buffering) 하고 조정(arbitration) 할 수 있는 메커니즘을 제공해야 함을 의미한다. 
메일 시스템은 특정 대상에게 전송된 통신을 해당 대상에 대응하는 메일 큐(mail queue) 에 배치한다. 대부분의 경우, 메일 큐는 메일 시스템의 일부로 간주된다. 그러나 통신의 도착 순서와 관련된 문제(예: 메일 수신 보장)를 다룰 때는 메일 큐를 명시적으로 고려해야 한다.

액터는 다음과 같이 기술할 수 있다:
- 메일 주소: 그 주소에 대해 충분히 큰 메일 큐가 존재한다.
- 행동(behavior): 수락된 통신을 기반으로 정의되는 함수이다.

추상적으로, 액터는 도착한 모든 통신이 순서대로 배치되는 메일 큐와, 메일 큐의 특정 셀을 가리키는 액터 머신(actor machine) 으로 구성된다고 볼 수 있다. 
메일 큐에서 하나의 통신의 끝은 특별한 기호를 사용해 표시할 수 있다. 이러한 구조는 그림 3.1과 같이 도식화할 수 있다.
<img width="531" height="386" alt="image" src="https://github.com/user-attachments/assets/3463a42e-e623-4fc5-b640-3e6a44d0a705" />

액터 머신 $`X_n`$이 메일 큐에서 n번째 통신을 수락하면, 그 액터는 새로운 행동을 수행할 새로운 액터 머신 $`X_{n+1}`$을 생성한다. 
이 새 머신은 메일 큐에서 n+1 번째 통신이 놓이는 셀을 가리킨다. 이 과정은 그림 3.2와 같이 도식화할 수 있다.
<img width="522" height="587" alt="image" src="https://github.com/user-attachments/assets/4fc95c02-6d53-47cf-a53f-01d12630954f" />

액터 머신 $`X_n`$과 $`X_{n+1}`$는 서로의 동작에 영향을 주지 않는다. 
$`X_n`$은 오직 n번째 통신만을 처리한다. 물론, $`X_n`$이 자신에게 다시 통신을 보낼 경우, 
$`X_{n+1}`$이 그 통신을 처리하는 액터 머신이 될 수는 있다. 구체적으로, 각 액터 머신은 자신의 행동에 따라 자체적으로 작업(task)과 액터를 생성할 수 있다. 
$`X_n`$이 $`X_{n+1}`$을 생성하기 전에도 이미 작업과 액터를 일부 생성했을 수 있고, 생성 도중일 수도 있다. 
중요한 점은, $`X_n`$은 더 이상 통신을 받지 않으며, 다른 대체 행동을 지정하지도 않는다는 것이다.

이벤트(event) 를 "새로운 액터 또는 작업의 생성", 또는 "대체 행동의 지정"으로 정의하면, 어떤 액터가 통신을 수락하여 발생시키는 이벤트들의 순서는 부분 순서(partial order) 이다. 
하나의 메일 주소에 대해 생성되는 대체 액터 머신들의 순서는 전체 순서(total order) 를 형성하며, 이 순서는 해당 통신의 도착 순서와 동형(isomorphic) 관계이다. (이는 그림 3.2를 통해 쉽게 유추할 수 있다.)

액터 기반 계산에 대한 이벤트 기반 그림은 그림 3.3과 같은 생명선(lifeline) 을 사용한다. 각 액터는 통신을 수락하는 순서를 선형적으로 유지한다. 
<img width="527" height="511" alt="image" src="https://github.com/user-attachments/assets/ff21a716-8113-4f7a-bffe-d9054e07c53c" />

액터의 생명선에는 그 액터의 이벤트가 시간 순으로 기록된다. 아래쪽으로 내려갈수록 더 나중의 로컬 시간이다. 액터 간의 인과 관계는 선으로 연결되며, 선 위의 화살표가 인과 방향을 나타낸다. 
마지막으로, 각 생명선에는 아직 처리되지 않은 보류 중인 통신(pending communications) 이 표시된다. 
Clinger(1981)는 이 생명선의 모음을 사용하여 액터의 고정점 의미론(fixed-point semantics) 을 정의했다. 이 도식들이 바로 액터 이벤트 다이어그램(actor event diagrams) 이다.

마지막으로 구현과 관련된 몇 가지 일반적인 논평이 이어진다.
주석 1. 독자는 수신한 각 커뮤니케이션에 대해 새로운 액터 머신을 구성하는 것이 효율적인지에 대해 의문을 가질 수 있다. 이는 단지 개념적인 가정일 뿐이며, 특정 구현 방식의 세부 사항에서 자유로워지기 위한 것이다. 동시성이란 단지 잠재적인 병렬성을 의미한다. 어떤 구현에서는 일반적으로 이전 머신이 "해체(cannibalized)"될 수 있을 때까지 대체 머신의 구성을 지연시키는 것이 유용할 수 있다. 그러나 대체 머신 구성을 지연시키는 것은 순차적 머신에서처럼 보편적인 요구사항은 아니다. 따라서 충분한 자원이 있다면, 액터 시스템에서는 대체 행동을 결정하는 데 필요한 존재론적 필요조건이 충족되자마자 다음 커뮤니케이션을 진행함으로써 계산 속도를 순서 차원에서 향상시킬 수 있다. 이런 종류의 파이프라이닝의 장점은 다음과 같은 간단한 예제로 설명할 수 있다:

입력 크기를 $`O(n)`$이라 할 때, 계산이 $`O(n^2)`$의 순차적 단계로 구성된다고 가정하자. 그리고 각 대체 머신을 계산하는 데는 $`O(n)`$단계만 걸린다고 하자. 
만약 정적인 아키텍처에서 $`O(m)`$개의 프로세스를 사용한다면, 계산 하나당 $`O(n^2)`$사이클이 필요하다. 
그러나 액터 기반 아키텍처에서는 파이프라이닝을 통해, 이전 계산의 대체 머신이 계산되자마자 다음 계산을 시작할 수 있기 때문에, 단일 계산에 소요되는 시간 동안 총 m개의 계산을 수행할 수 있다. 
이는 대체 머신 계산에 $`O(n)`$단계만 필요하기 때문이다.

주석 2. 액터 머신의 구조는 극도로 병렬적이라는 점도 지적할 필요가 있다. 어떤 커뮤니케이션을 수락함으로써 요구되는 계산의 특정 부분이 완료되면, 그 계산을 수행했던 "머신"의 해당 부분에 사용된 자원은 즉시 다른 작업에 사용 가능하다. 순차적 프로세스의 관점에서 생각할 경우, 액터의 동작에 내재된 병렬성을 상상하기 어려울 수 있다. 순차적 프로세스에서 계산의 구조는 선형적이며, 일반적으로 프로시저 호출은 스택에 쌓이며 각 호출은 자신의 상태를 저장한다. 그러나 액터 프로그램에서는 할당 명령(assignment command)의 부재 덕분에, 액터 행동의 명세에 포함된 명령들이 동시에 실행될 수 있다.

트랜잭션을 위한 계산을 계속 수행하게 해주는 customer의 사용과 같이 동시성을 생성하기 위한 구체적인 메커니즘은 이 장의 후반부에서 논의할 것이다.

#### 3.2 액터 기반 프로그래밍
이 절에서는 최소한의 액터 언어 커널을 위해 필요한 구성 요소들을 정의한다. 또한 간단한 액터 프로그램 예제를 제시한다.
이 예제들은 메시지 전달이 제어 구조, 프로시저 및 데이터 추상화 구현을 위한 일반적인 메커니즘으로서 얼마나 유연하게 활용될 수 있는지를 보여준다. 또한 포인터 타입 대신 메일 주소(mail address)를 사용하는 데이터 구조도 예제로 보인다. 
제어 구조를 메시지 전달 패턴으로 표현하는 것이 가능하다는 점은 [Hewitt 77]에서 처음 제안되었다.

단순함에도 불구하고 액터 언어의 커널은 매우 강력하다. 이 언어는 액터 패러다임에서 계산(computation)의 여러 중요한 특징을 포착한다. 여기에는 다음과 같은 기능들이 포함된다:

- 계산을 동시 실행 가능한 여러 요소로 분산하는 능력
- 제어 구조가 허용하는 최대 수준의 병렬성 생성
- 절차적 정보와 선언적 정보의 통합
- 데이터 추상화 및 절대적 캡슐화
- 프로그램에서 사용되는 식별자의 참조 투명성

액터는 하나의 메시지만을 “입력”으로 수신한다. 따라서 만약 어떤 계산이 여러 다른 액터들로부터 오는 메시지에 의존한다면, 그것은 액터들의 시스템을 통해 정의되어야 한다. 
우리는 이처럼 다중 입력 함수를 보다 명확하게 표현할 수 있도록 언어적 구성 요소들을 도입할 것이다. 하지만 그러한 구성 요소들 또한 최소 액터 언어로 정의 가능한 액터들을 바탕으로 표현할 수 있으므로, 본 절에서는 커널 언어에 필요한 구성 요소들에 국한하여 논의한다.

#### 3.2.1 기본 구성 요소
액터 시스템의 초기 구성을 정의하기 위해서는 몇 개의 액터를 생성하고, 그들에게 메시지를 보내야 한다. 
하지만 우리는 구성의 모듈성을 증진하기 위해 "외부", 즉 구성 내부에서 정의되지 않은 액터들과 통신할 수 있는 액터들을 명시한다. 액터 언어의 프로그램은 다음으로 구성된다:

- 행동 정의(behavior definitions): 특정 식별자와 행동 스키마를 연관시키며, 실제로 액터를 생성하지는 않는다.
- new 표현식(new expressions): 새로운 액터를 생성한다.
- send 명령어(send commands): 작업(task)을 생성하는 데 사용된다.
- 접수처 선언(receptionist declaration): 외부로부터 메시지를 받을 수 있는 액터들을 나열한다.
- 외부 선언(external declaration): 프로그램에 정의된 액터 집단에는 속하지 않지만, 구성 내부에서 메시지를 보낼 수 있는 액터들을 나열한다.

우리는 최소 언어에서 사용 가능한 각각의 표현식의 문법과 의도된 의미를 논의한다. 일부 간단한 표현식에 대해서는 가능한 문법 예시도 함께 제시한다.

**행동 정의(Defining Behaviors)** <br>
액터는 메시지를 하나 수신할 때마다, 자신의 대체 행동(replacement behavior) 을 계산한다. 이 대체 행동 또한 또 다른 대체 행동을 가지므로, 액터의 행동을 완전히 명시하려면 잠재적으로 무한한 정의가 필요하다. 
물론 우리는 각 대체 행동을 위한 무한한 문자열을 작성할 수 없다. 다행히도 수학에서 익숙한 재귀(혹은 귀납적) 정의의 원리가 존재한다.

본질적으로, 우리는 각 행동을 하나 이상의 식별자로 매개변수화(parameterize) 한다. 이 식별자들은 행동 정의 내에서 자유 변수로 사용된다. 행동 정의를 사용할 때에는 이러한 식별자들에 대한 구체적인 값들을 함께 지정해야 한다. 
예를 들어, 은행 계좌의 행동은 계좌의 잔고(balance)에 따라 달라진다. 따라서 우리는 계좌의 행동을 잔고의 함수로 정의한다. 특정 계좌를 생성하거나, 해당 행동 정의를 사용하는 새로운 대체 행동을 명시할 때는, 그 잔고에 대한 구체적인 값이 주어져야 한다.

한편, 들어오는 메시지의 값 역시 무한한 수가 가능하므로, 행동 정의는 들어오는 메시지의 함수로 표현된다.
행동 정의에는 두 개의 식별자 리스트가 사용된다:

- 지인 목록(acquaintance list): 액터가 생성될 때 값이 주어져야 하는 매개변수들의 리스트이다.
- 메시지 목록(communication list): 들어오는 메시지로부터 바인딩되는 매개변수들의 리스트이다.

액터가 생성되고 메시지를 수신하면, 이 바인딩된 식별자들을 통해 정의된 환경에서 명령어들을 실행하게 된다.

