## Actors: A Model of Concurrent Computation in Distributed Systems. 

Gul Agha (1985)

<br>

## Chapter 1. Introduction

모든 언어의 목적은 의사소통에 있으며, 프로그래밍 언어의 목적은 컴퓨터에게 수행해야 할 동작을 전달하는 것이다. 프로그래밍 언어 설계에서는 보통 두 가지 목표 중 하나를 강조하게 된다. 바로 **실행 효율성(efficiency)** 과 **표현력(expressiveness)** 이다.
여기서 “효율성”이란, 프로그램에 포함된 동작을 컴퓨터가 얼마나 빠르게 수행할 수 있는지를 의미한다. 엄밀한 의미에서 가장 효율적인 언어는 컴퓨터에게 직접적으로 수행할 명령을 전달하는 언어, 즉 기계어(machine language)라고 할 수 있다.¹
반면, “표현력”이란 프로그램의 의미를 쉽게 이해하고, 그것이 올바르게 동작함을 쉽게 보여줄 수 있는 능력을 말한다. 합리적인 동작을 가장 간결하게 표현할 수 있을수록, 그 언어는 표현력이 높다고 할 수 있다.

¹ 물론, 각 프로세서는 고유의 기계어를 가지며, 어떤 기계어는 다른 것보다 “본질적으로” 더 효율적일 수도 있다.

실행 효율성만을 극대화하는 프로그래밍 언어가 반드시 최상의 성능을 보장하는 프로그램을 만들게 하는 것은 아니다. 
이는 프로그래머가 “무엇을 표현할지”보다 “어떻게 표현할지”에 더 많은 시간을 소비할 수 있기 때문이다. 
실제 성능 향상은 동일한 결과를 더 낮은 계산 복잡도로 수행할 수 있는 방법을 찾음으로써 이루어진다.
대체로 새로운 프로그래밍 언어들이 등장한 이유는, 더 복잡한 동작을 더 쉽게 표현하기 위한 것이다. 
초기에는 컴퓨터가 주로 잘 정의된 수학 함수를 계산하는 데 사용되었지만, 현대 컴퓨터는 훨씬 다양한 작업을 수행한다. 
예를 들어, 정보 저장, 정렬 및 탐색, 불완전하게 정의된 영역에 대한 실시간 탐색 등이 점점 더 중요해지고 있다. 
자동차 등록 정보 데이터베이스, 화성 표면을 탐사하는 자율주행 차량 같은 인공지능 응용도 대표적인 예다. 
이처럼 컴퓨터 프로그램의 사용 범위가 넓어지면서, 우리가 표현하고자 하는 동작의 종류도 더욱 일반적이고 복잡해졌다.

새로운 언어들이 일반적으로 표현력을 효율성보다 중시해 왔음에도 불구하고, 우리는 점점 더 복잡한 문제를 컴퓨터로 해결할 수 있게 되었다. 
이 놀라운 경향은 더 크고 더 빠른 프로세서를 만드는 기술 덕분에 가능했다. 그러나 이제는 개별 프로세서의 크기나 속도를 더 늘리는 것이 한계에 다다랐을 가능성이 있다. 
실제로, 많은 수의 더 작은 프로세서를 협력적으로 사용할 수 있다면 훨씬 더 비용 효율적일 것이다. 이는 곧, **병렬성(parallelism)** 을 활용해야 한다는 뜻이다.

이제 이 논문의 핵심 주제, 즉 동시성을 위한 적합한 언어의 개발로 넘어간다. 여기서 **동시성(concurrency)** 이란 여러 동작을 잠재적으로 병렬로 실행하는 것을 의미한다. 
사실, 동시성 자체는 새로운 개념이 아니다. 타임셰어링(time-sharing)으로 인한 소프트웨어 혁명에서도 동시성은 이미 활용되어 왔다.
하지만 운영체제의 전통적인 문제와 우리가 지향하는 동시성 활용 간에는 중요한 차이가 있다. 운영체제에서는 여러 사용자 프로세스가 서로 간섭하지 않도록 하는 것이 올바른 동작의 핵심이다.
그러나 우리가 풀고자 하는 문제는 이와 정반대다. 여러 개의 프로세스가 유의미하게 협력하여 함께 동작하도록 하고자 한다.

여기서 “프로세서” 대신 “프로세스”라는 용어를 사용하는 데 주목하자. 프로세서는 물리적인 장치인 반면, 프로세스는 추상적인 계산 단위다. 
운영체제 이론으로부터 우리는, 여러 프로세스를 동시 실행함으로써 하나의 프로세서를 더 효과적으로 사용할 수 있음을 알고 있다. 
물론, 이러한 프로세서의 실제 활용은 언어를 지원하는 네트워크 아키텍처에 의존한다. 그러나 우리는 이 구현의 구체성에 관계없이 동시성을 모델링하는 방식 자체에 관심을 가진다.
즉, 프로세스들이 네트워크 상에 분산되어 병렬로 실행되더라도, 프로그래밍 언어가 동시성을 지원하지 않으면 이러한 아키텍처는 단일 프로세서보다 나은 성능을 내지 못한다.

사실, 우리는 특정 프로그래밍 언어 자체보다는 동시성 언어의 구조를 뒷받침하는 메타 언어적(meta-linguistic) 개념에 더 관심이 있다. 
언어의 작동 의미론(operational semantics)은 추상 기계(혹은 액터 모델에서는 기계 시스템)에 대한 명령어 집합을 정의한다. 
우리의 관심사는 이러한 계산 모델의 특성, 특히 표현력과 효율성이 동시성에서 어떻게 발현되는가에 있다.

동시성 이론이 필요한 내재적 이유도 존재한다. 대표적인 예는 지능적 시스템과 공동체를 이해하는 데 동시성이 필수적이라는 점이다. 
예를 들어, 학습하거나 적응하는 자연 시스템은 모두 본질적으로 병렬적이며, 그 규모는 매우 크다. 
동물의 뇌, 생태계, 사회 조직(인간이든 비인간이든)은 모두 동시성을 활용하는 분산 시스템이다. 
더 나아가, 적응과 자연 선택의 근간인 유전 알고리즘(genetic algorithm) 역시 본질적으로 병렬적이다 [Holland 75]. 
이들 시스템이 보여주는 성공은 동시 처리(concurrent processing)의 함의를 연구할 강력한 동기를 제공한다.

이 장의 나머지 부분은 논문 전체의 개요를 제공한다.

**2장**에서는 모든 동시성 모델에서 고려해야 할 일반적인 설계 결정을 살펴본다.

**3장**에서는 액터의 동작을 설명하고, 액터의 구체적인 예시를 다룰 수 있는 간단한 액터 언어를 정의한다.

**4장**에서는 액터 언어를 더 표현력 있게 만들어주는 고수준 구성 요소들을 정의하고, 추상화 메커니즘도 제공한다.
이러한 구성 요소들은 기본 액터 구성 요소를 기반으로 정의되며, 액터 형식주의의 일부로 간주되지 않는다. 또한 표현 언어(expression language)를 정의하고, 다양한 평가 전략도 논의한다.

**5장**에서는 액터 시스템 구성에 대한 전이 관계를 명시함으로써 액터 언어의 작동 의미론을 정의한다. 메시지 전달 보장을 위해 두 번째 전이 시스템도 정의하며, 최소 구성 요소들이 어떻게 작동 의미론적으로 정의될 수 있는지를 보여준다.

**6장**에서는 관련 모델들에서 제기된 문제들을 다룬다. 특히, 발산(divergence)과 교착 상태(deadlock)와 같은 병렬 시스템의 병적 동작을 액터 모델이 어떻게 다루는지를 살펴본다. 
액터의 비동기, 버퍼링된 통신 방식은 의미론적 교착 탐지를 가능하게 하며, 전통적인 의미의 교착 상태는 액터 시스템에서는 존재하지 않는다. 또한 데이터플로우 모델과 액터 모델 간의 유사성도 논의한다.

**7장**에서는 추상화(abstraction)와 구성 가능성(compositionality) 문제를 다룬다. 특히 개방형 시스템(open system) 개념을 소개하며, [Brock and Ackerman 77]에서 언급한 이력 관계(history relation)의 불충분성을 설명한다. 
적절한 추상화 수준은 서로 동등한 시스템을 의미론적으로 동일하게 다루고, 동등하지 않은 시스템을 구분할 수 있게 한다. 우리는 액터의 조합을 어떻게 모델링할 수 있는지도 논의한다.

**마지막 장(8장)** 에서는 본 논문의 함의들을 요약한다.

부록에서는 Milner의 도구를 이용하여 액터 시스템을 비동기 통신 트리(Asynchronous Communication Trees)로 표현하는 추상적 표현을 정의하며, 이는 액터 계산을 시각화하는 데 유용하다.

<br>

**기여 (Contributions)** <br>
이 논문의 구체적인 기여는 다음과 같다:
- 다양한 동시성 모델에 대한 비판적 개관
- 액터 모델의 간단한 개요와 액터 언어를 위한 최소 구성 요소 정의
- 액터 시스템을 위한 전이 시스템과 작동 의미론 제시
- 분산 컴퓨팅의 문제를 다룰 수 있는 패러다임 제안 (개방형 시스템에 적합)
- 불필요한 세부사항으로부터의 추상화와 구성 가능성을 지원하는 모델 제시

