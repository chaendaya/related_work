# A Polymorphic RPC Calculus

Kwanghoon Choi, James Cheney, Simon Fowler, Sam Lindley

<br>
<br>

## Abstract

RPC 계산법(RPC calculus)은 Links와 같은 멀티티어 프로그래밍 언어를 위한 간단한 의미론적 기반으로, 클라이언트-서버 모델에서 위치가 지정된 함수를 작성할 수 있도록 한다. 
이후 등장한 **정형화된 RPC 계산법(typed RPC calculus)** 은 함수의 위치 정보를 타입으로 포착하고, 위치 타입에 기반한 분할 컴파일(slicing compilation)을 가능하게 하기 위해 고안되었다. 
그러나 현재 위치의 사용은 모노모픽(monomorphic) 형태에 한정되어 있으며, 이는 클라이언트-서버 모델을 위한 RPC 계산법 이론을 실제로 적용하는 데 있어 극복해야 할 한계 중 하나이다.

본 논문은 프로그래머가 **다형적 위치 구성(location polymorphism constructs)** 을 이용해 간결한 멀티티어 프로그램을 작성할 수 있도록 하는 
다형적 RPC 계산법(polymorphic RPC calculus)을 제안한다. 
그런 다음, 이러한 다형적 멀티티어 프로그램은 기존의 분할 컴파일 방식에 적용 가능한 위치 상수(location constants)만을 포함하는 프로그램으로 자동 변환될 수 있다. 
우리는 다형적 RPC 계산법을 위한 타입 시스템을 정식화하고, 그 타입 안전성을 증명한다. 
또한, 타입 및 의미론적 정당성을 보장하는 모노모피제이션 변환(monomorphization translation)을 설계하고, 이에 대한 정당성 증명도 함께 제시한다.

키워드: 멀티티어 프로그래밍, 위치 다형성, 원격 프로시저 호출, 클라이언트-서버 모델

<br>
<br>

## 1.Introduction

클라이언트-서버 모델을 위한 멀티티어 프로그래밍 언어는 클라이언트와 서버 간의 이분법적 구조를 해결하기 위해 설계되었다. 
예를 들어, 웹 시스템은 기본적으로 데이터베이스에 접근하는 웹 서버와 사용자 인터페이스를 제공하는 웹 클라이언트로 구성되며, 이들은 네트워크로 연결되어 있다. 
프로그래머는 두 기계에 각각 실행될 별도의 프로그램을 작성해야 하므로, 개발 부담이 커진다. 
하나의 프로그램을 완성한 뒤에는, 두 프로그램을 함께 테스트해야 하며, 이는 단일 기계에서 실행되는 프로그램보다 훨씬 복잡하다. 
또한, 두 프로그램 중 하나라도 진화할 경우, 그 일관성을 유지해야 하는 어려움이 따른다. 
게다가 일부 작업은 두 컴퓨터 간의 경계를 넘나들기 때문에, 별도로 개발된 클라이언트-서버 모듈 간의 결합도(coupling)가 증가하게 된다.

멀티티어 프로그래밍은 이러한 문제를 해결하기 위해 클라이언트와 서버 표현식을 하나의 통합된 프로그램으로 작성할 수 있도록 하며, 
이 통합 프로그램을 자동으로 클라이언트 프로그램과 서버 프로그램으로 나눌 수 있는 분할 컴파일(slicing compilation) 기법을 제공한다.

언타입드 RPC 계산법(Cooper and Wadler, 2009)은 멀티티어 웹 프로그래밍을 위한 함수형 언어인 Links(Cooper et al., 2007)의 원격 프로시저 호출(RPC) 기능을 위한 의미론적 기반이다. 
아래는 RPC 계산법 논문에서 발췌한 예제를 Links 언어로 다시 작성한 것이다:

<img width="661" height="210" alt="image" src="https://github.com/user-attachments/assets/9413d5ec-f717-488f-b231-bdd9dffb8243" />
<br>
<br>

위 예제에서 client와 server는 각 함수가 어느 위치에서 실행되어야 하는지를 나타낸다. 
프로그램은 클라이언트 함수인 main에서 시작되고, 이후 서버 함수인 authenticate를 호출한다. 
그리고 authenticate 내부에서는 다시 클라이언트 함수인 getCredentials를 호출한다. 이는 각각 클라이언트에서 서버로, 서버에서 클라이언트로의 원격 호출 예시이다.
RPC 계산법에서는 이러한 원격 호출도 단순한 람다 적용(lamda application)의 형태로 표현된다. 
지역 함수 호출(print 등)과 동일한 문법을 사용하므로, 특히 고차 함수가 자주 사용되는 경우에는 해당 호출이 원격 호출인지 아닌지를 직관적으로 구분하기 어렵다.
이후, 언타입드 RPC 계산법에서는 이러한 통합 프로그램을 클라이언트와 서버 각각의 위치에서 실행되어야 할 함수만 포함하는 개별 프로그램으로 자동 분할하며, 
원격 호출은 통신 원시 연산자(primitive)를 통해 구현된다.

정형화된 RPC 계산법(Choi and Chang, 2019)은 함수가 실행되어야 할 위치 정보를 타입으로 명시하는 **위치 타입(location type)** 을 도입한 확장이다. 
예를 들어, authenticate는 타입 Unit −s→ String, getCredentials는 String −c→ String 타입을 가지며, 여기서 s는 서버, c는 클라이언트를 의미한다. 
이 계산법은 타입 수준에서 원격 호출을 명확히 표현할 수 있으며, 단순하면서도 효과적인 타입 기반 분할 컴파일 기법을 제공한다. 이 기법은 두 가지 분할 스타일을 가능하게 한다:
- 상태를 유지하지 않는(stateless) 서버: 확장성에 유리
- 상태를 유지하는(stateful) 서버: 클라이언트와의 다중 상호작용에 적합
또한, 두 스타일을 혼합하는 아이디어도 제안되었다. (자세한 내용은 Choi and Chang, 2019 참조)
Links 언어에서 client, server와 같은 위치 속성은 실행 시 힌트로 사용되지만, 정형화된 RPC 계산법에서는 타입의 일부로 사용된다는 점이 다르다.

이러한 발전에도 불구하고, 클라이언트-서버 모델에서 RPC 계산법 이론을 실제 적용하기 위한 몇 가지 한계점이 여전히 존재한다. 
정형화된 RPC 계산법은 웹 페이지 수정, 데이터베이스 접근 등 특정 위치에서 동작하는 함수를 작성하는 데는 적합하지만, 
리스트 유틸리티나 기본 타입 함수처럼 위치 중립적인 함수를 작성하는 데는 비효율적이다. 프로그래머는 동일한 기능을 클라이언트용과 서버용으로 두 번 작성해야 하기 때문이다.
따라서, 계산법은 위치 중립적인 함수를 한 번만 작성하면 클라이언트용과 서버용으로 자동 변환되는 기능을 제공해야 한다. 
이는 다양한 타입에 대해 한 번만 작성한 다형적 함수가 여러 타입에 대해 재사용 가능한 점과 유사하다.

그러나 멀티티어 언어와 RPC 계산법에 위치 다형성(polymorphic location)을 도입하는 것은 기술적으로 어려운 문제를 야기한다. 
RPC 계산법에서는 원격 호출과 지역 호출이 동일한 문법으로 표현되며, 별도의 rpc 키워드가 없다. 
이는 사용자 입장에서 통신의 차이를 추상화하는 좋은 설계이지만, 구현 관점에서는 지역 호출은 점프 명령어로, 
원격 호출은 RPC 라이브러리 호출로 처리되어야 하므로 두 호출을 명확히 구분할 필요가 있다.
정형화된 RPC 계산법은 함수의 위치 타입을 통해 이 차이를 구분한다. 그러나 위치 다형성을 도입하게 되면, 위치 변수가 도입되어 컴파일 타임에 위치 정보가 불확실한 상황이 생긴다.

본 논문은 정형화된 RPC 계산법을 기반으로 **위치 다형성(polymorphic location)** 을 도입한 다형적 RPC 계산법(polymorphic RPC calculus)을 제안한다. 
핵심 아이디어는 다음과 같다:
람다 추상(lambda abstraction) 위에 위치 변수를 도입하여, 위치를 추상화(Λl.M)하고, 이후 위치 적용(location application)을 통해 명시적 위치를 할당(M[Loc])한다.

예를 들어, 위치 중립적인 map 함수는 다음과 같이 작성된다: fun map(f, xs) l { the body of map }
이를 형식화하면: 
```math
map = Λl. λ^l f. λ^l xs. ... body ...
```


타입은 다음과 같다: $`∀l.(A −l→ B) −l→ ([A] −l→ [B])`$
map[c]는 클라이언트 위치에서 실행될 map 함수를 생성하며, map[s]는 서버 위치에서 실행될 map 함수를 생성한다.
이처럼 다형적 람다 추상은 위치 중립적이며, 위치 적용을 통해 구체적인 실행 위치를 정한다.

이 논문은 다형적 RPC 계산법에서의 위치 추상 및 위치 적용 구문을 제거하여, 
기존의 정형화된 RPC 계산법을 위한 분할 컴파일 기법을 그대로 활용할 수 있도록 변환(transformation)을 설계하였다. 이를 통해 새로운 두 가지 분할 컴파일 기법을 제안한다.

이 논문의 기여는 다음과 같다:
위치 다형성 개념을 포함하는 새로운 다형적 RPC 계산법을 제안하고, 그 타입 안전성(type soundness)을 증명하였다.
다형적 RPC 계산법을 위한 모노모피제이션 변환(monomorphization translation)을 설계하고, 그 타입 정당성 및 의미론적 정당성을 증명하였다.


