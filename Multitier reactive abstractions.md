# Multitier reactive abstractions



## 초록
분산 애플리케이션은 전통적으로 분산 시스템 내 각 구성 요소에 대해 별도의 모듈을 사용하여 개발되며, 이러한 모듈은 서로 다른 프로그래밍 언어로 작성되기도 한다. 이러한 모듈들은 다른 모듈에 의해 생성된 사용자 입력과 같은 이벤트에 반응하며, 차례로 다른 모듈에 의해 처리될 새로운 이벤트를 생성할 수 있다. 따라서 대부분의 분산 애플리케이션은 본질적으로 반응형이다.
분산 이벤트 기반 데이터 흐름은 시스템을 추론하기 어렵게 만들며, 그로 인해 분산 시스템 개발을 어렵게 만든다.
본 논문에서는 이러한 애플리케이션의 개발을 용이하게 하고 다양한 분산 아키텍처를 지원하는 분산 반응형 프로그래밍을 위한 언어 추상화를 제시한다.

범주 및 주제 분류어
D.3.3 [프로그래밍 언어]: 언어 구성 요소 및 기능

일반 용어
언어, 설계

키워드
분산 프로그래밍, 반응형 프로그래밍

## 1. 동기
오랜 연구의 역사에도 불구하고, 분산 애플리케이션 개발은 여전히 도전 과제로 남아 있다. 복잡성의 주요 원인 중 하나는 분산 애플리케이션이 종종 이벤트 기반이라는 점이며 [1, 10], 서로 다른 호스트 간에 데이터와 제어 흐름을 전송해야 한다는 점이다 [15].

이 두 측면은 분산 애플리케이션의 동작을 추론하기 어렵게 만든다. 그 이유는 실행 시 동작이 개별 모듈 간의 이벤트 상호작용에 따라 달라지기 때문이다. 이러한 이벤트의 발생은 예측할 수 없으며 잠재적으로 상호 얽힐 수 있다 [5, 7]. 따라서 구성 요소 간의 잠재적 이벤트, 제어 흐름, 데이터 흐름을 추적하는 것은 어렵다.

개발 과정에서 모듈로 분리함으로써, 개발자는 각 모듈에 대한 로컬한 관점만 가지게 되며 전체 시스템 내 다른 모듈과의 상호작용에 대해서는 인지하지 못할 수 있다. 개발자가 간과한 이벤트는 시스템의 예기치 못한 동작으로 이어질 수 있다. 그 결과, 개발자가 로컬 환경에서 분산 환경으로 전환할 때 심각한 문제에 직면하게 된다 [12].

게다가 분산 애플리케이션을 개발할 때, 개발자는 각 구성 요소에 적합한 소프트웨어 스택을 선택해야 하며, 이에 따라 다양한 프로그래밍 언어들을 모두 숙지해야 한다. 이로 인해 매우 복잡할 수 있는 많은 양의 보일러플레이트 연결 코드(glue code)를 개발하고 유지관리해야 한다 [9].

이러한 복잡성의 일부는 멀티티어(multitier) – 때때로 티어리스(tierless)라고도 불림 – 프로그래밍과 반응형 프로그래밍(reactive programming, RP) 을 통해 해결될 수 있다. 이 두 기법은 분산 애플리케이션 개발의 복잡성을 줄이는 것을 목표로 한다.

멀티티어 언어는 분산 애플리케이션 개발에 필요한 복잡성과 보일러플레이트 코드의 양을 줄이기 위해 설계되었다. 이를 달성하기 위해, 전체 애플리케이션(모든 티어를 포함하여)은 단일 멀티티어 언어로 개발된다. 서로 다른 티어 간의 간극은 일반적으로 컴파일러가 채워주며, 개발자는 실제 애플리케이션 로직 작성에 집중할 수 있고 보일러플레이트 코드를 작성하느라 시간을 낭비하지 않아도 된다.

객체지향 패러다임에서는 애플리케이션의 반응형 측면을 전통적으로 옵저버(Observer) 디자인 패턴을 통해 구현한다. 하지만 이 패턴은 제어 흐름의 반전(inversion of control flow), 상태를 변경하기 위한 부수효과(side-effecting) 연산 유도 등의 여러 문제점을 가지고 있다 [4].

함수형 반응형 프로그래밍(FRP, Functional Reactive Programming) [6]은 옵저버 패턴의 문제를 극복하기 위해 설계된 프로그래밍 패러다임이다. FRP는 데이터 흐름을 더 직접적이고 직관적인 방식으로 정의할 수 있게 한다. 반응형 값을 선언하면, 반응형 시스템은 해당 값의 모든 의존성을 추적하고, 의존성 중 하나가 변경되었을 때 해당 값을 업데이트한다.

반응형(reactives)은 옵저버보다 유지보수성과 구성 가능성(composability)이 더 우수하다 [8, 11].

그러나 이 두 기술 모두, 분산 애플리케이션 내에서의 이벤트 기반 데이터 흐름과 관련된 문제의 범위를 해결하지는 못한다.

## 2. 문제
우리는 1절에서 설명한 복잡성이 대부분 **우연적(accidental)**이며, 부적절한 추상화에 기인한다고 주장한다. 기존의 추상화는 분산 애플리케이션 개발을 위한 문제의 범위를 충분히 다루지 못하며, 다음과 같은 방식으로 복잡성을 줄이기에 불충분하다:

I. 여러 호스트에 걸친 데이터 흐름을 직접 명시할 수 있는 기능을 제공하지 않으며,
II. 분산 시스템의 모든 구성 요소를 전체 시스템에 대한 추론이 가능하도록 매끄럽게(seamless) 개발할 수 있도록 지원하지 않으며,
III. **호스트 간의 안전 속성(safety properties)**을 보장하지 않는다.

최신의 분산 애플리케이션 개발 방식은 위에서 언급한 속성들 중 하나 이상(I, II, III)을 간과하고 있으며, 이것이 본 연구의 동기를 제공한다.

전통적으로 분산 시스템의 서로 다른 구성 요소들은 개별 모듈로 개발된다. 이러한 모듈들은 심지어 서로 다른 프로그래밍 언어로 개발될 수도 있으며, 이로 인해 구성 요소 간의 상호작용을 추론하기 어려워지고, 결국 분산 시스템 전체의 동작을 이해하기 어렵게 된다.
우리는 이러한 문제를 해결하기 위해 멀티티어(multitier) 접근 방식(cf. II)에서 영감을 받았다.

또한, 전통적인 접근 방식은 서로 다른 호스트 간의 데이터 흐름에 대해 컴파일러 수준의 **타입 안전성(type safety)**을 제공하지 못한다.
우리가 제안하는 언어 추상화는 시스템 내 여러 호스트에 걸친 데이터 흐름을 타입 안전하게 명시할 수 있도록 지원한다 (cf. III).

기존의 분산 프로그래밍용 멀티티어 언어들, 예를 들어 Hop [14] 또는 Links [3] 등은, 일반적으로 호스트 간의 데이터 흐름을 직접 명시할 수 있도록 지원하지 않는다.
한 호스트에서 다른 호스트로의 데이터 흐름은 **원격 프로시저 호출(remote procedure call)**이나 **콜백(callback)**을 통해 모델링되어야 한다.
우리는 **반응형 언어(reactive languages)**에서 데이터 흐름 명시 방식에 대한 영감을 얻었으며, 이를 분산 시스템의 여러 구성 요소에 걸쳐 직접 명시할 수 있도록 지원한다 (cf. I).

심지어 멀티티어와 반응형 프로그래밍의 통합을 목표로 하는 기존 언어들조차도, 예를 들어 Ur/Web [2] 같은 언어는, 반응형 시스템이 분산 시스템의 단일 구성 요소 내부로 제한되어 있다.
따라서 여러 호스트에 걸친 데이터 흐름을 직접 명시할 수 있는 기능은 제공하지 못한다.

기존 멀티티어 언어에 대한 또 하나의 일반적인 단점은, 클라이언트–서버(client–server) 애플리케이션 이외의 다양한 분산 애플리케이션 아키텍처에 대한 지원 부족이다.
Ur/Web, Hop, Links와 같은 멀티티어 언어는 클라이언트–서버 웹 개발에 초점을 맞추고 있다.
이러한 한계는 멀티티어 반응형 프로그래밍의 깊은 통합을 목표로 하는 기존 접근 방식들, 예를 들어 Scala Multi-Tier FRP [13]에도 해당된다.
