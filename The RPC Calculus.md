# The RPC Calculus

**The RPC Calculus** (2009)

Ezra E. K. Cooper, Philip Wadler

- https://www.researchgate.net/publication/221336394_The_RPC_calculus

<br>
<br>

---

## Abstract

최근 몇몇 언어 설계는 위치를 명시하는 표기를 갖춘 분산 시스템을 위한 통합 언어를 제안해 왔으며, <br>
우리는 이를 **"위치 인식(location-aware)" 언어**라고 부른다. <br>
이러한 언어는 프로그래머가 코드가 실행되어야 할 위치(예: 호스트의 선택)를 제어할 수 있도록 하는 구문을 제공하며, <br>
이는 보안이나 성능 측면에서 유용하다.

한편, 웹 시스템 엔지니어링의 핵심 원칙은 웹 서버가 **"상태를 저장하지 않는(stateless)"** 방식이어야 한다는 것이다. <br>
즉, 개별 클라이언트를 위한 **세션 상태**<br>
—클라이언트 프로그램이 상호작용의 어느 지점에 위치해 있는지를 나타내는 상태—를 유지해서는 안 된다. <br>
그러나 많은 위치 인식 언어의 구현은 서버 측에 **클라이언트 전용 상태**를 유지하기 때문에 웹 환경에 적합하지 않다.<br>

본 논문에서는 **대칭적인 위치 인식 언어**를 **무상태 서버** 위에서 구현하는 방법을 제안한다.<br>

> 주제 분류: D.3.3 [프로그래밍 언어] – 언어 구성 및 기능
> 
> 
> **일반 주제어:** 언어, 이론

<br>
<br>

---

## 1. Introduction

웹 서버를 설계할 때는 **사용자 상태**를 어떻게 다룰지 신중히 고민해야 한다. <br>
데스크톱 애플리케이션은 한 번에 하나의 사용자만 처리하고, <br>
기존 네트워크 시스템은 여러 요청을 처리하더라도 더 통제된 환경에서 운영된다. <br>
반면, 단순한 웹 시스템조차 하루에 수만 명의 사용자와 상호작용하며, <br>
각 사용자는 동시에 여러 창을 열 수 있고, 언제든 서버에 알리지 않고 떠날 수 있다.<br>

이러한 특성 때문에, **웹 서버가 사용자 세션에 관한 상태를 유지하는 것은 현실적으로 불가능하다**. <br>
웹 프로그래밍의 핵심 원칙은 다음과 같다:

**“상태를 제거하라! (Get the state out!)”** <br>
— 서버가 아니라 **클라이언트**에 상태를 유지하라는 것이다. <br>
효율적인 웹 서버는 요청에 빠르게 응답하고, 그 요청을 더 빠르게 잊어버려야 한다. <br>

그럼에도 불구하고, 최근 몇몇 고수준 언어 설계([15, 17, 16])는 <br>
**클라이언트와 서버를 포괄하는 지속적인 환경**을 제공하는 **"위치 인식 언어"** 를 제공한다. <br>
이를 통해 프로그래머는 클라이언트와 서버 간 제어 흐름을 자유롭게 이동시킬 수 있으며, <br>
한 언어 내에서 양쪽의 자원을 활용할 수 있다.<br>

본 논문은 **상태를 유지하는 클라이언트**와 **무상태 서버** 환경에서 <br>
이러한 위치 인식 언어를 구현하는 방법을 보여준다. <br>

웹 엔지니어링에서 말하는 **"무상태 서버"** 란, 서버가 저장소를 아예 가지지 않는다는 뜻이 아니라, <br>
**각 클라이언트의 실행 흐름에 대한 상태를 저장하지 않는다**는 의미다. <br>
웹 서버는 데이터베이스처럼 지속적인 데이터를 저장하긴 하지만, <br>
이는 특정 클라이언트의 일시적인 상태를 위한 것이 아니다.<br>

따라서 도전 과제는, 프로그래밍 언어처럼 **투명하게 제어 상태를 유지**하면서도, <br>
무상태 서버 기반에서 이 상태를 **명시적으로 관리**하는 방법을 찾는 것이다.<br>

<br>

**핵심 기법**

본 논문은 세 가지 핵심 기법을 사용한다:

1. **디펑셔널라이제이션(defunctionalization)** – Reynolds의 기법을 따름 <br>
2. **Continuation-Passing Style (CPS) 변환** <br>
3. **트램펄린(trampoline)** – 서버 응답 내부에 클라이언트로의 요청을 터널링하는 기법 <br>

이 중 CPS와 디펑셔널라이제이션은 Matthews 외 [13]가<br>
웹 상호작용을 CPS 대신 **직접 스타일(direct style)** 로 표현하기 위해 사용한 바 있다. <br>
본 논문은 이에 더해 트램펄린을 도입하여, 위치 인식 언어에서 **RPC 호출을 지원**한다.<br>

이 기능은 **Links 언어** [5]에도 부분적으로 내장되어 있다. <br>
현재 Links에서는 최상위 함수에 대해서만 클라이언트-서버 간 제어 이동이 가능하지만, <br>
본 논문은 이 제한을 **완화**하는 방법을 제안한다.<br>

즉, 기존 제한된 구현은 CPS 변환과 트램펄린만으로 가능하지만, <br>
**중첩된 원격 함수 정의(nested remote-function definitions)** 를 구현하려면 <br>
**디펑셔널라이제이션**이 추가로 필요하다.<br>

<br>

**본 논문의 제안**

- **위치 주석이 추가된 단순 고차 람다 계산법**을 제안한다.<br>
  이를 통해 프로그래머는 코드의 실행 위치를 명시할 수 있다.<br>
  
- 이 계산법의 의미론은 각 연산이 **어디서 실행 가능한지(location semantics)** 를 정의하며,<br>
  이는 **RPC 기능이 내장된 언어의 의미론**으로 볼 수 있다.<br>

- 그런 다음, 이 계산법을 **비대칭 클라이언트-서버 환경**을 모델링하는 1차 계산법으로 변환하는 방법을 제시하며,<br>
  이 변환이 **원래 계산법의 위치 의미론을 보존함**을 보인다.<br>

  <br>
  <br>

---

## 5. 관련 연구

**위치 인식(location-aware) 언어들**

우리가 아는 한, 본 연구는 정적 서버 모델 위에 위치 인식 언어를 구현하는 방법을 처음으로 제시한 연구이다. 
그러나 위치 인식 언어의 이론 및 구현에 대한 연구는 이미 풍부하다.

Lambda5 [15, 14]는 항(term)과 값(value)의 위치와 이동을 제어하는 구문을 가진 위치 인식 계산(calculus)이다. 
Lambda5는 이러한 런타임 이동에 대해 세밀한 제어를 제공하지만, 우리의 계산은 일반적인 λ-바인딩 스코프 규율을 따르며 데이터 이동에 관대하다. 
Lambda5도 마찬가지로 운영 모델로의 변환 과정에서 CPS 변환을 사용하며, 우리는 디펑셔널라이제이션(defunctionalization)을 사용했지만, 
Lambda5는 유사한 기법인 클로저 변환(closure conversion)을 사용한다. Lambda5는 상태를 유지하는 서버 모델을 기반으로 하므로 트램펄린(trampoline)은 필요하지 않다.

Neubauer와 Thiemann [17]은 위치 주석이 붙은 순차 프로그램을 별도의 병렬 프로그램으로 분리하고, 
이들이 채널을 통해 통신하도록 만드는 알고리즘을 제시하였다. 
기본적으로 그들의 시스템은 대칭적인 두 피어(peer) 시스템을 요구하며, 비대칭적인 클라이언트-서버 관계는 고려하지 않는다. 
그들은 “웹 애플리케이션의 특수한 경우에도, HTTP 위에 채널을 구현하는 중재자(mediator)가 있다면 우리의 프레임워크가 적용 가능하다”고 언급하는데, 
우리가 제안한 트램펄린 기법이 바로 그러한 중재자의 역할을 수행한다. 
이들은 세션 타입(session types)을 사용하여 상호작용 동안 각 프로세스의 채널 사용이 타입적으로 안전함을 증명하지만, 
본 연구의 서버는 항상 수신 가능한(stateless) 구조로, 해당 방식과는 다르다.

Ohori와 Kato [19]는 프로그래머가 위치별로 코드를 파일로 나누고, 전역 이름 테이블을 통해 값을 가져올 수 있는 위치 기반 언어를 제안하였다.
이들은 이를 명시적인 RPC 호출이 있는 저수준 언어로 변환하는데, 이러한 호출은 네트워크를 통해 전달 가능한 구체적인 타입에 제한된다. 
이들 역시 위치 간 상호 접근이 가능한 저수준 모델을 사용하며, 본 논문과는 차이가 있다.

**보안 관점에서**, 
Zdancewic 외 [24]는 괄호(brackets)를 사용하는 계산 모델을 개발했으며, 이는 본 논문의 `λ_hi`에 대한 모델로 작용하였다. 
그들의 연구는 괄호 내부에서 타입 변환을 수행하는 타입 시스템을 통해, 특정 위치(또는 주체)가 인터페이스를 통해 전달되는 특정 값을 관찰하지 못하도록 보장할 수 있음을 보여준다. 
이와 같은 타입 시스템은 본 논문에서 클라이언트와 서버 간 정보 흐름 보안을 다루는 데 적용 가능하다. 
Matthews와 Findler [12]는 여러 언어가 하나의 시스템에서 작동하는 경우를 모델링한 거의 동일한 의미론을 제시했는데, 
여기서 언어들은 다른 시스템에서의 주체 또는 위치와 유사하게 작용한다.

**디펑셔널라이제이션**

John Reynolds [22]에 의해 간결하지만 비공식적으로 소개된 디펑셔널라이제이션은 이후 여러 연구들 [3, 2, 21, 18, 1]을 통해 타입 기반 환경에서 형식화되고 검증되었다. 
본 논문에서는 타입이 없는(untyped) 환경에서 디펑셔널라이제이션을 형식화했는데, 이는 타입에 따라 함수 적용 로직을 분리할 필요가 없어 약간 더 간단하다. 
Danvy와 Nielsen [8], Danvy와 Millikin [7]은 디펑셔널라이제이션의 다양한 응용 및 특성을 탐구하였다.

디펑셔널라이제이션은 람다 리프팅(lambda-lifting) [11]과 유사하지만, 
후자는 클로저를 검사 가능한 값으로 구체화(reify)하지 않기 때문에 본 논문처럼 네트워크를 통해 직렬화하여 전송하는 경우에는 적합하지 않다.

Murphy [14]는 디펑셔널라이제이션 대신 클로저 변환을 사용하였다. 
이 경우 변환된 클로저는 여전히 코드 포인터를 포함하고 있는데, 이는 서버가 실행 중일 때만 유효하므로 정적(stateless) 서버 구현에는 부적합할 수 있다.

**Continuation-Passing Style (CPS)**

CPS 변환은 1970년대 [9, 20]부터 시작되어 [23]에 이르기까지 풍부한 역사와 연구가 있다.

**트램펄린 스타일**

Ganz 외 [10]는 꼬리형(tail-form) 프로그램에 트램펄린 스타일을 도입하였다. 
꼬리 호출(tail call)마다 호출을 직접 수행하는 대신, 다음 호출을 나타내는 '텅크(thunk)' 값을 생성해 반환하는 방식이다. 
이렇게 반환된 텅크는 트램펄린이라 불리는 루프에서 해석되며, 즉시 실행하거나 다른 동작과 조합되는 방식으로 처리된다. 
트램펄린 스타일 프로그램은 항상 유한한 작업만 수행한 후 다음 텅크를 반환한다. 이들은 CPS를 포함하는 꼬리형 프로그램을 트램펄린 스타일로 변환하는 방법을 제시하였다.

본 논문에서 제시한 시스템도 트램펄린 스타일의 인스턴스라고 할 수 있는데, 
클라이언트에서 서버로의 모든 원격 호출은 트램펄린으로 래핑되고, 서버에서 클라이언트로의 원격 호출은 트램펄린 바운스로 변환된다. 
단, 로컬 함수 호출은 직접 실행되며, 이는 기존 트램펄린 스타일과의 차이점이다.

**확장 연구**

Corcoran 외 [6]는 위치 인식 언어인 Links에 타입 시스템을 도입하여, 데이터 항목에 보안 정책을 부여하고, 프로그램의 런타임 동작이 이러한 정책을 위반하지 않음을 정적으로 보장하였다. 
이들은 Links의 저수준 위치 의미론을 고려한 방식으로 접근하였다.

<br>
<br>

---

## 6. 결론 및 향후 연구

우리는 위치 인식 언어를 CPS 변환과 트램펄린을 사용하여 비대칭적이고 정적인 클라이언트-서버 계산으로 컴파일하는 방법을 제시하였다. <br>
이를 통해 서버의 호출 스택을 클라이언트 측 값으로 표현하였다. 향후 다음과 같은 방향으로 확장하고자 한다.<br>

- 현재의 원시 계산은 위치 주석이 필요한데, 이러한 주석 작성은 프로그래머에게 부담이 될 수 있다.<br>
  Neubauer [16]의 작업을 응용하여, 통신 비용을 최소화하도록 위치 주석을 자동으로 할당할 수도 있다.<br>
  동적 위치 행동(dynamic location behavior)을 예측하기 어렵고, 다양한 통신 및 계산 비용 모델이 존재하며, <br>
  보안과 같은 다른 고려사항도 있어 문제는 다면적이다.<br>
  
- 예외 처리를 포함한 언어 기능을 추가하고, 각 위치 주석에 단일 위치가 아닌 여러 허용 위치를 지정할 수 있도록 일반화하고자 한다.<br>
  또한 `λ_hi` 계산을 Links 언어로 구현할 계획이다.<br>
  
- 본 논문은 제어 상태(control state)라는 단순한 형태의 상태만을 다룬다.<br>
- ML 스타일로 참조를 갖는 저장소(store)를 추가하고자 할 수 있으며, 참조는 생성된 위치에 존재하는 것으로 처리할 수 있다.<br>
- 상태 없는 서버를 유지하기 위해 저장소를 직렬화하고, 서버에 위치한 데이터는 암호화하여 서버만 읽을 수 있도록 하면 된다.<br>
- 이 경우 Corcoran 외 [6]의 보안 중심 타입 시스템이 특히 유용할 수 있다.<br>
  
- 다른 형태의 상태, 예를 들어 디스크나 데이터베이스 등과의 지속적 트랜잭션은 직렬화가 어렵기 때문에 더 문제가 된다.<br>
  향후 연구에서는 제한적인 상태 보존을 허용하고, 이를 관리하는 기능을 도입할 수 있다.<br>
