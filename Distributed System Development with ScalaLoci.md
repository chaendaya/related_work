# Distributed System Development with ScalaLoci

분산 애플리케이션은 전통적으로 개별 모듈로 개발되며, 종종 서로 다른 언어로 작성된다. 이러한 모듈들은 사용자 입력과 같은 이벤트에 반응하고, 차례로 다른 모듈들을 위한 새로운 이벤트를 생성한다.
구성 요소로의 분리는 시간 소모적인 통합 과정을 요구하며, 통신을 수동으로 구현해야 하기 때문에 개발자는 저수준의 세부 사항을 직접 다루어야 한다.
이 두 요소의 결합은 분산된 데이터 흐름이 여러 모듈에 걸쳐 흩어지게 만들어, 전체 시스템에 대한 추론을 어렵게 만든다.

ScalaLoci 분산 프로그래밍 언어는 이러한 문제들을 **배치 타입(placement types)**에 기반한 일관된 모델을 통해 해결한다.
이 모델은 분산 데이터 흐름에 대한 추론을 가능하게 하며, 다양한 소프트웨어 아키텍처를 전용 언어 기능을 통해 지원하고, 저수준 통신 세부사항 및 데이터 변환을 추상화한다.
우리가 보여주듯, ScalaLoci는 분산 시스템 개발을 단순화하고, 오류가 발생하기 쉬운 통신 코드를 줄이며, 버그의 조기 발견을 용이하게 한다.

CCS 개념어:
• 소프트웨어 및 공학 → 분산 프로그래밍 언어; 도메인 특화 언어
• 계산 이론 → 분산 계산 모델

추가 키워드:
분산 프로그래밍, 멀티티어 프로그래밍, 반응형 프로그래밍, 배치 타입, 스칼라

## 1. 서론 (INTRODUCTION)
오랜 연구의 역사에도 불구하고, 분산 애플리케이션 개발은 여전히 도전 과제이다.
복잡성의 주요 원인 중 하나는 분산 애플리케이션이 서로 다른 호스트 간에 데이터와 제어 흐름을 전송해야 한다는 점이며 [Thekkath et al. 1994], 또 다른 원인은 그것들이 종종 이벤트 기반이라는 점이다 [Carzaniga et al. 2001; Meier and Cahill 2005].

이 두 측면은 분산 시스템에 대한 추론을 복잡하게 만든다.
그 이유는 시스템의 런타임 동작이 이벤트를 통해 개별 모듈 간에 이루어지는 상호작용에 의존하며, 이러한 이벤트는 예측할 수 없고 잠재적으로 서로 얽힐 수 있기 때문이다 [Edwards 2009; Fischer et al. 2007].

첫째, 각 모듈이 개별적으로 개발되면, 개발자는 오직 **로컬한 시야(local view)**만을 가지게 되어 전체 시스템의 상호작용을 이해하기 어렵다.
둘째, 구성 요소 간의 잠재적인 이벤트, 제어 흐름, 데이터 흐름을 추적하는 것은 번거로울 수 있다.

이러한 문제들은 멀티티어(multitier) – 때로는 **티어리스(tierless)**라고도 불리는 – 프로그래밍과 **반응형 프로그래밍(reactive programming)**을 통해 해결되고자 했다.
멀티티어 프로그래밍은 분산 애플리케이션 개발의 부담을 줄이는 것을 목표로 하며, 반응형 프로그래밍은 직접적인 데이터 흐름 명시를 가능하게 하는 기술이다.

멀티티어 언어는 분산 시스템 개발을 단일 호스트 애플리케이션 개발에 더 가깝게 만들고자 하며, 서로 다른 구성 요소 간의 분산 및 원격 통신을 추상화할 수 있는 수단을 제공한다.
멀티티어 언어를 사용하면, 개발자는 단일 언어를 통해 클라이언트와 서버 등 서로 다른 티어의 기능을 같은 컴파일 단위 안에서 혼합하여 사용할 수 있다.

컴파일러는 이러한 컴파일 단위를 자동으로 분할하여 각 티어에 배포할 모듈을 생성하고, 필요한 통신 코드를 자동으로 생성해 준다
[Cooper et al. 2007; Neubauer and Thiemann 2005; Serrano et al. 2006].
이 결과, 개발자는 데이터 변환이나 네트워크 통신 같은 세부사항을 처리할 필요 없이 실제 애플리케이션 로직에 집중할 수 있다.

**반응형 프로그래밍(RP)**은 반응적이고 이벤트 기반의 애플리케이션을 개발하기 위한 접근법이며, 구성 가능성이 높고, 코드가 간결하며 [Salvaneschi and Mezini 2014], 이해하기 쉬운 코드를 유도한다 [Meyerovich et al. 2009; Salvaneschi et al. 2014a].
초기 RP 솔루션들은 순수 함수형 언어에 초점을 맞추었으며 [Elliott and Hudak 1997], 정확성 [Hudak et al. 2003]과 효율적인 구현 [Elliott 2009]을 연구했다.

이후 연구는 RP를 주류 언어(mainstream languages)로 확장하여 산업적으로 널리 채택되었다.
예시로는 다양한 언어에 제공되는 Reactive Extensions / Rx [Meijer 2010], FrTime [Cooper and Krishnamurthi 2006] (Scheme), Flapjax [Meyerovich et al. 2009] (JavaScript), Scala.React [Maier et al. 2010], REScala [Salvaneschi et al. 2014b] (Scala)가 있다.

하지만 위 기술들은 여전히 분산 시스템 개발을 위한 잠재력을 충분히 실현하지 못하고 있다.
기존의 멀티티어 언어들은 대부분 웹 애플리케이션 내의 클라이언트–서버 모델에 초점을 맞추고 있으며, 일반적인 분산 아키텍처에 대한 지원은 부족하다.
이러한 언어들 [Chlipala 2015; Cooper et al. 2007; Philips et al. 2014; Radanne et al. 2016; Rajchenbach-Teller and Sinot 2010; Reynders et al. 2014; Serrano et al. 2006]은 주로 서버 측 코드와 자바스크립트 간의 불일치 문제, 데이터베이스 쿼리 통합, DOM 조작과 같은 문제에 집중하고 있다.

또한, 웹 환경에서는 클라이언트 주도형 상호작용이나 상태 없는 REST 서버와 같은 특정 가정이 가능하지만, 이러한 가정은 일반적인 분산 시스템에서는 성립하지 않는다.

게다가, RP와 멀티티어 프로그래밍은 제대로 통합되어 있지 않다.
RP는 데이터 흐름을 통한 값의 전파에 집중하며, 분산 애플리케이션과 매우 잘 맞는다. 왜냐하면 많은 경우 분산 애플리케이션은 반응형이기 때문이다 [Eugster et al. 2003; Pietzuch and Bacon 2002].
이벤트(예: 네트워크 메시지, 사용자 입력 등)는 호스트 간에 데이터를 전달하고, 상태 변경이나 새로운 이벤트를 유발한다.

그러나 기존의 RP 추상화는 구성 요소 간의 경계를 넘지 못하며, 기존의 멀티티어 언어들 – 예를 들어 Hop [Serrano et al. 2006]이나 Links [Cooper et al. 2007] – 은 RP 추상화를 지원하지 않는다.
RP 기능을 제공하는 멀티티어 언어, 예: Scala Multi-Tier FRP [Reynders et al. 2014]는 웹 도메인에 국한되어 있다.
또한 RP 추상화를 제공하는 일부 멀티티어 언어들, 예: Ur/Web [Chlipala 2015]은 반응형 값을 단일 구성 요소 내로 제한하며, 여러 호스트에 걸친 데이터 흐름을 정의할 수 없다.

우리는 ScalaLoci라는 멀티티어 반응형 언어를 제안한다. 이 언어는 분산 애플리케이션을 위한 새로운 조합의 추상화를 제공한다.

첫째, 우리는 기존 방식이 연산(computation)에만 위치를 할당하는 것과 달리, **데이터에도 위치(location)를 연관짓는 배치 타입(placement types)**을 제안한다.
이로써 웹 도메인을 넘어 배치에 대한 정적 추론을 가능하게 한다.

둘째, 우리는 **멀티티어 반응형 값(placed reactives)**을 지원하며, 개발자가 여러 분산 구성 요소에 걸친 데이터 흐름을 조합할 수 있도록 한다.

이러한 기능 조합 덕분에, 우리는 ScalaLoci가 분산 시스템 개발의 복잡성을 다루는 데 있어 중대한 진보를 제공한다고 믿는다.

요약하자면, 본 논문은 다음과 같은 기여를 한다:

• ScalaLoci의 설계를 제시한다. 여기에는 언어 내부에서 분산 아키텍처를 명시하는 기능, 배치 타입, 다중 호스트에 걸친 데이터 흐름을 위한 반응형 추상화가 포함된다.
• 원격 값과 로컬 값 간의 상호작용이 타입 안전하며, 아키텍처 명세를 위반하지 않도록 검증하는 타입 시스템을 가진 ScalaLoci의 핵심 계산 모델을 개발하고, 이를 Coq로 형식화했다.
• 멀티티어 코드를 분산 구성 요소로 컴파일하고, 기존 IDE와의 호환성을 유지하는 Scala 기반 구현을 제공한다.
• Apache Flink, Apache Gearpump, 그리고 22개의 소형 사례 연구를 포함한 사례 연구를 통해 본 접근을 평가하고, ScalaLoci 애플리케이션이 더 나은 설계와 더 높은 안전성을 보인다는 것을 입증한다.
Amazon EC2 분산 환경에서의 마이크로 벤치마크 및 시스템 벤치마크 결과, 이러한 장점들이 무시할 수 있을 정도의 성능 비용만을 발생시킨다.

논문은 다음과 같이 구성되어 있다:
2장에서는 ScalaLoci의 추상화를 제시하고,
3장에서는 예제를 통해 이를 보여주며,
4장에서는 ScalaLoci의 장애 허용(fault tolerance) 메커니즘을,
5장에서는 실행 모델을,
6장에서는 형식화를,
7장에서는 구현을,
8장에서는 평가를,
9장에서는 관련 연구를,
10장에서는 결론을 각각 다룬다.
