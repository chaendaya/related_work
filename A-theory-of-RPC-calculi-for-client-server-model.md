# A-theory-of-RPC-calculi-for-client-server-model
A Korean translation of the paper A Theory of RPC Calculi for the Client–Server Model.
<br>
<br>

## Abstract

다중 계층 프로그래밍 언어(multi-tier programming languages)를 사용하면 프로그래머는 코드가 실행될 위치를 명시함으로써 웹 기반 클라이언트-서버 모델에서 클라이언트와 서버 프로그램을 별도로 작성하고 이들을 함께 테스트해야 하는 개발 부담을 줄일 수 있다.
Cooper와 Wadler가 제안한 RPC 계산법은 이러한 언어들의 기초 중 하나로, 프로그래머가 임의로 깊게 중첩된 클라이언트-서버 상호작용을 작성할 수 있도록 대칭적 통신 기능을 제공한다. 이러한 계산법의 기능은 클라이언트-서버 모델에 적합한 트램폴린(trampolined) 스타일의 비대칭 통신으로 완전하게 구현된다.

<pre>
전통적인 웹 프로그래밍에서는 클라이언트(e.g. JavaScript)와 서버(e.g. Node.js, Python)를 따로 작성
이런 구조에서는 서로 통신하는 방식(RPC, API 호출 등)을 따로 맞추고 테스트해야 하며 이는 개발과 유지보수에 부담

다중 계층 언어는 이 문제를 해결하기 위해 
하나의 프로그램 안에서 코드의 실행 위치(location)를 명시
-> 하나의 통합된 언어로 클라이언트-서버 프로그램을 작성할 수 있음
-> 개발 효율 높아짐
     
Cooper와 Wadler는 이러한 다중 계층 언어를 위한 형식적 기반으로 RPC 계산법을 제안함
  
대칭적 통신 : 클라이언트가 서버를 호출하는 것뿐만 아니라 서버도 클라이언트를 호출할 수 있고
              양방향 호출이 자유롭게 중첩될 수 있음
e.g. 클라이언트 -> 서버 -> 클라이언트 -> 서버와 같이 호출이 깊게 중첩된 형태로 구성 가능

프로그래머는 대칭적인 통신을 쓰는 것처럼 보이지만
실제 네트워크 상에서는 이를 트램폴린 스타일로 비대칭 통신으로 바꿔서 실행

트램폴린 스타일 : 하나의 프로그램 흐름에서 다른 위치(클라이언트나 서버)로 건너뛰며 실행을 계속하는 방식
</pre>

하지만 기존 연구는 서버의 상태를 클라이언트로 전송하기 위해 모두 인코딩하고, 서버에 상태를 저장하지 않는 상태 없는(stateless) 서버 전략만을 고려한다. 이로 인해 디스크나 데이터베이스와 같은 상태 기반 연산을 항상 올바르게 처리하긴 어렵다. 이 문제를 해결하기 위해, 우리는 프로그래머 관점에서는 대칭적 통신을 완전히 지원하면서도, 구현은 트램폴린 스타일의 비대칭 통신으로 이루어지는 새로운 상태 있는(stateful) 계산법을 제안한다. 기존의 계산법들은 모두 비대칭 통신 기능만 제공하거나, 대칭적 구현을 제안하되 이는 클라이언트–서버 모델이 아닌 피어 투 피어(peer-to-peer) 모델에 적합한 방식이었다.

<pre>
기존의 stateless RPC 계산법은 서버에 상태를 저장하지 않기 때문에 
디스크나 DB같은 현실적인 상태 연산을 제대로 처리하지 못함

이 한계를 극복하기 위해 "프로그래머에겐 대칭적으로 보이고, 
실제로는 비대칭적으로 실행되는" 상태 있는 계산법을 제안

이 방식은 클라이언트–서버 모델에 적합하며,
이전 방식들이 가졌던 구조적 한계를 넘어서는 새로운 설계임
</pre>

두 번째로, 우리가 제안하는 상태 있는 서버 전략은 새로운 위치 타입 시스템(locative type system) 을 기반으로 설계되었으며, 이는 클라이언트–서버 모델을 위한 RPC 계산법 이론의 기반을 마련한다. 우리는 새로운 상태 있는 계산법을 제안함과 동시에, 기존의 상태 없는 서버 전략을 개선하여 원격 프로시저 호출에서 실행 시 발생하는 검사(runtime check)를 제거한 새로운 상태 인코딩 계산법을 구성할 수 있도록 하며, 두 전략의 장점을 결합한 혼합 전략(mixed strategy) 의 설계도 가능하게 한다. 우리가 아는 한, 대칭 통신 기능을 프로그래머에게 제공하면서도 비대칭 통신 구현을 함께 지원하는 타입 기반 다계층 계산법은 세 가지 전략을 아우르는 방식으로는 아직 존재하지 않는다.

<pre>
상태있는 계산법은 위치 타입 시스템(location type system)이라는 새로운 타입 이론을 기반으로 설계

또한, 상태없는 계산법의 단점 중 하나였던
원격 호출 시의 실행 시 검사(runtikme check)를 제거할 수 있도록 인코딩 계산법 개선

-> 상태있는 계산법과 상태없는 계산법을 조합 가능
</pre>

<br>
<br>

---

## 1. Introduction

웹 시스템과 같은 현대의 컴퓨팅 환경은 단일 머신이 아닌 여러 분산된 머신을 함께 프로그래밍하는 것을 포함한다. 예를 들어, 웹 시스템은 기본적으로 데이터베이스에 접근하는 웹 서버와 사용자 인터페이스를 제공하는 웹 클라이언트로 구성되며, 이들은 네트워크로 연결되어 있다. 프로그래머는 이 두 머신을 위한 별도의 프로그램을 각각 개발해야 하므로 작업 부담이 커진다. 또한 두 프로그램을 함께 테스트해야 하므로, 단일 머신에서 하나의 프로그램을 테스트할 때보다 더 복잡하다.

멀티티어 프로그래밍 언어(Murphy VII 외, 2004; Neubauer & Thiemann, 2005; Balat, 2006; Serrano 외, 2006; Cooper 외, 2007; Murphy, 2008; Cooper & Wadler, 2009; Rastogi 외, 2014; Chlipala, 2015; Serrano & Prunet, 2016)를 사용하면 프로그래머의 작업 부담을 줄일 수 있다. 이러한 언어들은 코드의 특정 부분이 어디서 실행되어야 하는지를 지정하는 "위치(location)" 기능을 제공한다. 이 기능을 활용하면, 프로그래머는 서버와 클라이언트 같은 서로 다른 위치에서 사용될 수 있는 단일 프로그램을 하나의 언어로 개발할 수 있다. 그런 다음 컴파일러는 각 위치에 맞는 별도의 프로그램을 자동으로 생성하며, 서로 다른 위치에 있는 프로그램 간의 통신 무결성을 보장한다.

특히 RPC(Remote Procedure Call) 계산법(Cooper & Wadler, 2009)은 클라이언트와 서버 간 대칭적 통신(symmetric communication)의 기능을 제공한다. 각 함수에 대해 실행 위치를 지정하는 주석을 추가한 후, 프로그래머는 표준 함수들만으로도 임의로 깊게 중첩된 클라이언트–서버 상호작용을 작성할 수 있다. 이들의 컴파일 방식은 깊은 상호작용을 웹 시스템의 평탄한 요청–응답 인터랙션으로 자동으로 매핑한다. RPC 계산법은 Links(Cooper 외, 2007)라는 실용적인 멀티티어 웹 프로그래밍 언어의 기반이다.

RPC 계산법의 기존 대상 언어인 클라이언트-서버(CS) 계산법에서는 클라이언트와 서버가 별도의 프로그램을 실행하며, 서버는 개별 클라이언트와 세션을 유지하지 않도록 설계되었다. 클라이언트–서버 간 상호작용 중 발생하는 모든 서버 상태는 클라이언트로 전달되도록 적절히 인코딩되므로, 서버에 상태를 저장할 필요가 없다. CS 계산법은 비대칭 통신(asymmetric communication)을 사용하며 이는 클라이언트-서버 모델에서 거의 비용이 들지 않는다. 하지만 프로그래머 관점에서는 trampolined 스타일(Ganz 외, 1999)을 통해 대칭적 통신을 지원한다. 이러한 구현은 웹 서비스가 상태를 저장하지 않는 RESTful 아키텍처와 잘 맞는다.

그러나 기존의 RPC 및 CS 계산법은 디스크나 데이터베이스를 포함하는 상태 있는 연산(stateful operations)을 항상 올바르게 처리하지는 못한다. 디스크나 데이터베이스를 포함한 일부 서버 상태는 직렬화가 어려워, 예를 들어 두 데이터베이스 연산 사이에 클라이언트 함수를 호출할 경우, 클라이언트 함수 호출 이후에 남는 모든 서버 상태를 인코딩하기 어렵다. 설령 직렬화가 가능하더라도, 직렬화된 서버 상태를 클라이언트와 서버 사이에서 반복적으로 전달하는 것은 통신 오버헤드를 증가시켜 비효율적이다. 이 문제를 해결하기 위해 RPC 계산법에서 상태 있는 서버 전략이 필요하다. 이는 웹 시스템에서 상태 있는 상호작용을 지원하는 것이 일반적이기 때문에 자연스럽다. 예를 들어, Java의 HttpSession은 여러 페이지 요청이나 웹사이트 방문에 걸쳐 사용자를 식별하고, 해당 사용자에 대한 정보를 저장하는 수단을 제공한다.

<pre>
다중 계층 프로그래밍 언어는
하나의 언어 안에서 코드 조각마다 실행 위치를 지정할 수 있게 하여
하나의 통합된 프로그램을 작성하면 컴파일러가 위치별로 나누어 처리
-> 통신 무결성을 보장, 개발 단순화

다중 계층 프로그래밍 언어의 형식적 기반(이론 모델) 중 하나
: RPC 계산법

RPC 계산법은 클라이언트-서버 간의 대칭적 통신을 추상화하여
복잡한 상호작용을 표준 함수들만으로 기술할 수 있게 하며,
컴파일러가 이를 웹의 요청–응답 모델로 평탄하게 변환한다.
이는 Links와 같은 멀티티어 웹 언어의 기반이 된다.

CS 계산법은 RPC 계산법을 구현할 때의 목적 언어로 사용된다.
서버가 상태를 저장하지 않도록 설계되어 있어 RESTful 웹 아키텍처에는 잘 맞지만,
디스크나 데이터베이스를 포함한 상태는 다루기 어렵다.

따라서 서버가 자체적으로 상태를 유지할 수 있는 전략이 RPC 계산법에 필요
실제 웹 아키텍처에서도 이를 기술적으로 지원하는 것이 일반적임
</pre>


먼저, 기존 계산법의 문제를 해결하기 위해 상태 있는 서버 전략을 기반으로 한 새로운 계산법 λ<sup>state</sup><sub>rpc</sub> 및 λ<sup>state</sup><sub>cs</sub>를 도입한다 (그림 1 참고). 

![image](https://github.com/user-attachments/assets/62035d37-9abd-4745-8a22-549968c23ef1)

이 새로운 계산법은 전통적인 프로그래밍 언어들처럼 런타임 스택을 사용하여 서버 상태를 명시적으로 표현한다. 가장 중요한 점은, 새로운 계산법이 클라이언트-서버 모델에서 구현이 쉬운 trampolined 스타일을 사용함으로써 RPC 계산법의 대칭 통신 기능을 완전히 지원한다는 것이다. 지금까지 여러 멀티티어 웹 프로그래밍 언어들이 상태 있는 전략을 채택해 왔지만, 프로그래머 관점에서의 대칭 통신과 구현자 관점에서의 비대칭 통신을 모두 지원한 경우는 없다. 예를 들어, Hop(Serrano 외, 2006; Serrano & Prunet, 2016), Ur/Web(Chlipala, 2015), Eliom(Balat, 2006; Radanne, 2017)은 모두 클라이언트가 서버 함수를 자유롭게 호출할 수 있는 비대칭 통신만을 제공하고, 서버가 클라이언트 함수를 호출하려면 언어 구성 요소가 아닌 특별한 네트워크 라이브러리를 사용해야 한다. 예를 들어, Hop은 서버에서 클라이언트로의 통신을 위해 웹 리액티브 프로그래밍 라이브러리를 제공한다. 이들 언어의 상태 있는 전략은 대칭 통신을 완전히 지원하는 우리의 전략과는 다르다. Lambda5(Murphy VII 외, 2004; Murphy, 2008)는 프로그래머에게 대칭 통신을 제공하지만, 로컬 및 원격 함수에 대해 별도의 구문을 사용한다. 해당 구현의 개념은 클라이언트와 서버 같은 여러 "세계"에 걸친 continuation을 사용하는 점에서 유사하지만, 상태 있는 피어 전략(peer strategy)을 기반으로 한다. 분산 시스템에서 모든 머신에 대해 동일한 의미론 규칙을 사용하므로, 피어 모델의 의미론 설명과 클라이언트-서버 모델에 맞춘 구현 사이에 괴리가 생긴다. 클라이언트-서버 모델에 맞추기 위해서는 별도의 방법을 도입해야 한다. 또한, 이 전략을 상태 없는 서버 전략으로 만들기 위해서는 서버에 대한 의미론 규칙을 클라이언트와 다르게 구성해야 한다. 멀티티어 계산법(Neubauer & Thiemann, 2005) 역시 동시에 실행되는 프로세스를 다루기 때문에 Lambda5와 동일한 한계를 가진다.

둘째로, 우리가 설계한 상태 있는 서버 전략은 새로운 위치 타입 시스템(locative type system)을 기반으로 하며, 클라이언트-서버 모델을 위한 RPC 계산법 이론의 기반을 제공한다. 이 이론 하에서, 우리는 새로운 상태 있는 계산법뿐 아니라 기존의 상태 없는 서버 전략을 개선하여 런타임에서 원격 호출을 검사할 필요 없는 새로운 상태 인코딩 계산법 λ<sup>enc</sup><sub>rpc</sub>와 λ<sup>enc</sup><sub>cs</sub>를 구성할 수 있다 (그림 1 참고). 이 이론은 상태 인코딩 전략과 상태 있는 서버 전략의 장점을 결합한 새로운 혼합 전략을 설계하는 것도 가능하게 한다. 이에 대해서는 이후에 더 자세히 설명한다.

새로운 RPC 계산법 λ<sub>rpc</sub>는 기존 RPC 계산법의 타입이 있는 버전이며, 위치 a에서 실행되어야 하는 함수들을 위한 위치 함수 타입 $\tau \xrightarrow{a} \tau'$
을 포함한다. 위치 타입을 사용한 타입 지정은 기존 계산법들(단, RPC 계산법 제외)처럼 별도의 문법 요소를 사용하지 않고도 타입 수준에서 원격 함수 호출과 로컬 호출을 구분할 수 있다. 이 타입 정보를 기반으로 새로운 타입 지향 컴파일 방식(type-directed compilation)을 설계할 수 있다. 이는 기존의 untyped 방식보다 더 단순한다. 왜냐하면 기존 방식은 클라이언트를 위한 규칙 3가지, 서버를 위한 규칙 5가지 등 총 8가지 규칙이 필요했지만, 새 방식은 클라이언트용과 서버용 각각 1가지씩 총 2가지 규칙만 있으면 된다. 또한 타입 정보 덕분에 기존 방식에서 필요했던 실행 중 위치 검사(runtime location check)도 제거할 수 있다. 예를 들어, 기존 방식에서는 함수 적용 f M 이 로컬 함수인지 원격 함수인지 구별하지 않기 때문에 실행 시에 f가 원격 함수인지 확인해야 한다. 그러나 위치 타입을 사용하면, f가 로컬인지 원격인지 타입 수준에서 명확히 구분되므로 이러한 확인이 불필요해진다.

이 이론은 단순한 컴파일 방식과 위치 검사 제거의 이점뿐 아니라, 두 전략을 비교하고 결합할 수 있는 프레임워크도 제공한다. 동일한 이론 하에서 상태 인코딩 전략과 상태 있는 전략의 세션 관리 측면을 비교하는 것도 쉽다. 상태 인코딩 전략에서는 하나의 세션이 하나의 요청–응답 인터랙션에 해당하는 반면, 상태 있는 전략에서는 여러 요청–응답 인터랙션에 걸쳐 세션을 유지할 수 있다. 이에 대한 형식적 설명도 제공된다. 또한, 이 이론은 상태 인코딩 전략을 기본으로 사용하다가 필요할 경우 상태 있는 전략으로 전환하는 혼합 전략을 설계할 수 있게 한다. 이러한 혼합 전략은 상태의 모나딕 캡슐화(monadic encapsulation) 개념을 통해 실현될 수 있다 (Launchbury & Peyton Jones, 1994; Timany 외, 2017). 이 개념에 따르면, 상태 있는 계산은 모나드를 통해 캡슐화되며, 함수형 언어의 순수성과 분리될 수 있다. 우리의 설계에서는 상태 있는 연산이 필요한 부분에 대해 모나딕 타입 시스템으로 분리하여 상태 있는 계산법을 사용하고, 그 외의 순수 함수 연산에 대해서는 상태 인코딩 계산법을 사용한다.

평가를 위해, 우리는 위치 타입 추론 알고리즘을 포함한 λ<sub>rpc</sub>의 프로토타입 컴파일러와 두 종류의 계산법으로의 컴파일러를 구현했으며, HTTP 프로토콜을 사용하는 클라이언트와 서버 평가기를 각각 구현했다.

그림 1은 이 이론의 개요를 보여준다. 우리가 알기로는, 대칭 통신을 프로그래머에게 제공하면서, 비대칭 통신으로 구현되며 상태 없는 서버 전략, 상태 있는 서버 전략, 혼합 전략을 함께 지원하는 타입드 위치 계산법은 존재하지 않는다.

본 논문의 기여는 다음과 같다:
- RPC 계산법 λ<sub>rpc</sub>를 위한 위치 타입 시스템을 제안하고, 평가 과정에서 위치 정보가 보존됨을 보장하는 타입 건전성(type soundness)을 증명한다.

- λ<sub>rpc</sub>를 각각 λ<sup>enc</sup><sub>rpc</sub> 및 λ<sup>state</sup><sub>rpc</sub>로 컴파일하는 두 가지 의미론적으로 올바른 방식의 계산법을 설계한다.

- λ<sup>enc</sup><sub>rpc</sub>를 λ<sup>enc</sup><sub>cs</sub>로, λ<sup>state</sup><sub>rpc</sub>를 λ<sup>state</sup><sub>cs</sub>로 컴파일하는 두 가지 의미론적으로 올바른 CS 계산법을 설계한다.

- 위치 타입 추론 알고리즘, 두 종류의 컴파일러, 두 HTTP 기반 평가기를 구현하여 상태 없는 계산법과 상태 있는 계산법의 효과를 실험한다.

- 의미론 규칙에 세션 주석을 추가하여 λ<sup>enc</sup><sub>cs</sub>와 λ<sup>state</sup><sub>cs</sub>의 세션 관리 특성을 형식적으로 비교한다.

- RPC 계산법을 상태의 모나딕 캡슐화로 확장함으로써 두 전략을 혼합한 전략을 설계하는 방법을 제안한다.

제2장은 위치 타입 시스템을 포함한 RPC 계산법 λ<sub>rpc</sub>를 소개하고 그 타입 건전성을 증명한다. 제3장은 서버 상태 인코딩 전략의 새로운 정식화로서 λ<sup>enc</sup><sub>rpc</sub>와 λ<sup>enc</sup><sub>cs</sub>를 제안한다. 제4장은 이 정식화를 상태 있는 서버 전략을 적용한 λ<sup>state</sup><sub>rpc</sub>와 λ<sup>state</sup><sub>cs</sub>로 확장한다. 제5장은 관련 연구를 논의하며, 제6장은 본 논문을 결론짓는다. 부록에서는 본문에서 제시한 모든 정리의 증명을 포함한다.
