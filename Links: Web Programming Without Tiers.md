# Links: Web Programming Without Tiers


---
## Abstract

Links는 웹 애플리케이션을 위한 프로그래밍 언어로, <br>
하나의 소스 코드로 웹 애플리케이션의 세 가지 계층(클라이언트, 서버, 데이터베이스) 모두의 코드를 생성할 수 있다. <br>
클라이언트에서 실행되기 위해 JavaScript로, 데이터베이스에서는 SQL로 컴파일된다. <br>

Links는 'Ajax' 스타일이라 불리는 방식으로 동작하는 풍부한 클라이언트 기능을 지원하며, <br>
정적 타입 메시지 전달을 기반으로 한 동시성 프로세스도 지원한다. <br>

Links는 Java Servlets나 PLT Scheme 같은 기존 방식과는 달리, <br>
세션 상태를 서버가 아닌 클라이언트에 유지함으로써 확장 가능성(scalable)을 확보한다. <br>

클라이언트 측 JavaScript에서의 동시성과 클라이언트-서버 간의 계산 이전은 <br>
continuation-passing style(CPS)로의 변환을 통해 지원된다.<br>

<br>
<br>

---
## Introduction

일반적인 웹 시스템은 각각 다른 컴퓨터에서 실행되는 세 가지 계층으로 구성된다(그림 1 참조). 

![image](https://github.com/user-attachments/assets/13b77684-1ae5-487d-8ac1-60bc33e0d5e1)


중간 계층의 서버는 프론트엔드 브라우저로 보낼 페이지와 백엔드 데이터베이스에 보낼 쿼리를 생성한다. <br>
프로그래머는 다양한 언어들을 익혀야 한다. <br>
로직은 Java, Perl, PHP, Python의 혼합으로 작성되고, 페이지는 HTML, XML, JavaScript로, 쿼리는 SQL 또는 XQuery로 작성된다. <br> 
HTML 폼이나 SQL 쿼리가 Java 로직이 기대하는 타입의 데이터를 생성하는지 확신할 수 있는 쉬운 방법이 없다. <br>
이는 임피던스 불일치(impedance mismatch) 문제라 불린다. <br>

Links는 이 임피던스 불일치 문제를 하나의 언어로 세 계층 모두를 표현함으로써 해결한다. <br>
현재 버전의 Links는 브라우저에서 실행될 JavaScript와 데이터베이스에서 실행될 SQL로 번역된다. <br>
서버 컴포넌트는 O'Caml로 작성되었으며, <br>
이는 정적 분석 단계(Hindley-Milner 타입 검사 포함), JavaScript 및 SQL 변환기, <br>
그리고 서버에서 실행될 Links 코드를 위한 인터프리터로 구성된다. <br>

웹 애플리케이션 설계자들은 점점 더 많은 작업을 브라우저로 이전하고 있다. <br>
Google Mail과 Google Maps와 같은 "리치 클라이언트" 시스템은 "Ajax"라고 불리는 새로운 상호작용 방식을 사용한다. <br>
클라이언트 측의 Links는 JavaScript로 컴파일되며, 이는 대부분의 브라우저에서 널리 사용되는 함수형 언어다. <br>
JavaScript는 플랫폼마다 구현이 다양하기 때문에, 우리는 널리 호환 가능한 공통 하위 집합을 대상으로 컴파일러를 설계하였다. <br>
향후 Links를 Flash나 Java와 같은 추가 타겟 언어로 확장하는 것도 쉬울 것이다. <br>
하지만 우리는 Ajax의 인기가 높아짐에 따라, 향후 몇 년 안에 표준화되고 신뢰할 수 있는 JavaScript 버전들이 등장할 것으로 기대한다.<br>

Links는 엄격하고 정적 타입을 갖춘 함수형 언어이다. 다른 함수형 언어에서 입증된 다음과 같은 개념들을 통합하고 있다:

- Kleisli 등의 시스템에서 발전된 데이터베이스 쿼리 최적화<br>
- PLT Scheme 등의 언어에서 사용된 웹 상호작용을 위한 continuation<br>
- Erlang에서 도입된 메시지 전달 기반 동시성<br>

이 세 가지 기능 모두는 **불변값(immutable values)**을 사용하는 것이 가변 객체(mutable objects)보다 더 적합하다. <br>
Links에서 부작용(side effects)은 데이터베이스 및 화면 갱신, 동시 프로세스 간 통신에 한정되어 있으나 중요한 역할을 한다.<br>

타입 시스템은 브라우저의 폼, 서버의 로직, 데이터베이스 쿼리 간의 일관성을 보장하며, <br>
동시에 동시성 프로그래밍에서 메시지 송신자와 수신자 간의 타입 일치를 보장한다.<br>

Links 프로그램은 세션 상태를 서버가 아닌 클라이언트에 유지함으로써 확장 가능하다. <br>
상용 웹 툴(J2EE 등)과 대부분의 연구 기반 웹 툴(PLT Scheme의 현재 릴리즈, Mozart QHTML 등)은 이러한 방식의 확장성을 지원하지 않는다.<br>

Links에서는 모든 서버 상태를 직렬화하여 클라이언트로 전달하고, 필요할 때 다시 서버로 복원한다. <br>
이 방식은 PLT Scheme에서 널리 쓰이는 continuation-passing style을 확장한 resumption-passing style이다. <br>

Links의 함수는 클라이언트 또는 서버 중 어느 쪽에서 실행될지를 명시할 수 있으며, <br>
클라이언트에서 실행되는 함수는 서버의 함수를 호출할 수 있고 그 반대도 가능하다.<br>

<br>
<br>

*데이터베이스 프로그래밍* <br>
쿼리는 Links의 문법으로 작성되어 SQL로 컴파일되며, 이는 Kleisli에서 처음 제안되었고 현재는 LINQ에서도 사용된다. <br>

*웹 상호작용* <br>
프로그래밍 언어가 웹 상호작용을 지원할 수 있다는 개념은 MAWL 언어에서 처음 등장하였다.  <br>
함수형 프로그래밍의 continuation 개념은 특히 웹 클라이언트와의 상호작용을 개선하는 데 유용하게 사용되었으며,  <br>
Quiennec, Graham(Yahoo에서 사용된 상업적 시스템), Felleisen, Thiemann 등이 이를 발전시켰다. <br>

*동시성* <br>
Links는 클라이언트 측에서 공유하지 않는(share-nothing) 동시성을 지원한다.  <br>
프로세스 간 데이터 교환은 오직 메시지 전달을 통해서만 가능하며, 이는 Erlang과 Mozart에서 처음 도입된 방식이다. <br>

*XML 프로그래밍* <br>
Links는 XML 데이터를 구성하기 위한 편리한 문법을 제공하며, 이는 XQuery와 유사하다.  <br>
현재 버전은 XDuce 등에서 제공하는 정규표현식 타입을 지원하지 않지만, 이는 향후 버전에 추가될 수 있다.  <br>
정규표현식 타입은 이미 기존 연구에서 충분히 다루어졌기 때문에 우선순위는 낮다. <br>

*기타 웹 프로그래밍 언어들* <br>
다른 웹 프로그래밍 언어로는 Xtatic, Scala, Mozart, SML.NET, F#, Cω(Polyphonic C# 기반), Xen, HOP, Ocsigen 등이 있다.  <br>
이 언어들 대부분은 함수형 프로그래밍 커뮤니티의 영향을 받았으며, Links와 기능적으로 중첩되는 부분이 많다. <br>

하지만 이들 언어 중 어느 것도 Links처럼 하나의 소스 코드로 프론트엔드 클라이언트, 미들웨어 서버 로직, 백엔드 데이터베이스 쿼리를 모두 생성하는 것을 목표로 하지 않는다. <br>
Links의 가장 큰 매력은 이처럼 현재의 언어 파편화를 대신할 수 있는 단일 통합 언어라는 점이다. <br>

*논문의 구성* <br>
이 논문에서는 2장에서 Links의 예제를 소개하고, 3장에서는 동시성과 클라이언트-서버 상호작용 구현을 간략히 설명한다.  <br>
4장에서는 SQL로 컴파일 가능한 Links의 부분 집합과 SQL 컴파일 방식, 5장에서는 프로세스에 대한 타입 체계를 설명한다.  <br>
마지막으로 6장에서는 현재 구현의 한계, 7장에서는 결론을 제시한다. <br>

 <br>
  <br>
  
---
## 3. Client-server computing

Links 프로그램은 클라이언트(브라우저)와 서버라는 두 위치에서 실행되는 분산 프로그램으로 볼 수 있다.  <br>
프로그래머는 함수 정의에 주석을 달아 해당 함수가 어디에서 실행되어야 하는지를 선택적으로 지정할 수 있다.  <br>
클라이언트에 있는 함수는 서버의 함수를 호출할 수 있고, 반대로 서버 함수도 클라이언트 함수를 호출할 수 있다. <br>

이러한 **대칭성(symmetric interaction)**은 사실 웹 브라우저와 서버가 제공하는 비대칭적인(asymmetric) 메커니즘 위에 구현된 것이다.  <br>
현재 웹 표준은 오직 브라우저만이 서버의 함수를 호출하는 것을 허용한다.  <br>
서버는 실행을 마친 후 값을 브라우저로 반환할 수는 있지만, 서버가 브라우저의 함수를 직접 호출하는 방법은 제공되지 않는다. <br>

Links의 구현은 세션 상태(session state)가 서버가 아닌 클라이언트에 보존된다는 점에서 확장성(scalability)을 가진다.  <br>
웹 환경에서는 서버 자원이 매우 제한적이기 때문에, 서버가 실제로 작업을 수행할 때를 제외하고는 Links 구현은 서버 자원을 필요로 하지 않는다. <br>

우리는 이를 위해 continuation-passing style (CPS, 연속 전달 스타일)의 변형인 **resumption-passing style (RPS, 재개 전달 스타일)**을 사용한다.  <br>
최근 웹에서는 제어의 반전을 다시 반전시키기(invert back the inversion of control) 위해 CPS를 사용하는 것이 일반적이며,  <br>
이를 통해 서버가 클라이언트에 폼을 전송한 뒤에도 제어권을 유지할 수 있게 된다.  <br>
Links에서는 서버 측 프로세스가 클라이언트의 임의의 함수를 호출한 이후에도 제어권을 유지할 수 있게 한다. <br>
<br>

![image](https://github.com/user-attachments/assets/84b28110-89c5-4749-91ea-4d4efe2bd5d3)

그림 11은 Links가 제공하는 **호출/반환 방식(call/return style)**이 기존의 **요청/응답 방식(request/response style)**과 어떻게 다른지를 보여주며, <br>
요청/응답 방식이 호출/반환 방식을 어떻게 흉내낼 수 있는지도 보여준다.  <br>
왼쪽 그림은 "client" 및 "server" 주석이 붙은 함수들 간의 호출 순서를 보여준다.  <br>
실선은 이러한 호출에서 현재 활성화된 실행 흐름(thread of control)을 나타내며, 점선은 함수 반환을 기다리는 스택 프레임을 나타낸다.  <br>
이 예에서 main은 클라이언트 함수로서 서버 함수 f를 호출하고, f는 다시 클라이언트 함수 g를 호출한다.  <br>
이러한 호출 및 반환 패턴은 모든 프로그래머에게 익숙한 형태이다. <br>

오른쪽 그림은 같은 호출 시퀀스를 실제로 구현한 방식을 보여준다.  <br>
이때 점선은 로컬 저장소가 해당 계산의 일부로 사용되고 있음을 나타낸다.  <br>
g가 호출되었지만 아직 값을 반환하지 않은 동안, 서버는 로컬에 아무 것도 저장하지 않는다.  <br>
그럼에도 불구하고 언어는 f가 서버에서 "아직 기다리고 있는 것처럼" 보이게 만든다.  <br>
사실 서버의 모든 상태는 k라는 값에 캡슐화되어 있으며, 이는 호출 시 클라이언트에 전달된 것이다. <br>

이를 위해 프로그램은 두 개의 타겟(클라이언트와 서버)으로 컴파일되고, 클라이언트에서 실행을 시작한다.  <br>
이 컴파일 단계에서 서버에 주석이 달린 코드는 클라이언트에서 **원격 프로시저 호출(RPC)**로 대체된다.  <br>
이 RPC는 HTTP 요청을 통해 서버 함수와 인자 정보를 전달한다.  <br>
클라이언트 측 실행 흐름은 서버 함수가 실행되는 동안 사실상 **일시 중단(suspended)**된다. <br>

마찬가지로, 서버 측에서도 클라이언트 함수를 호출해야 할 경우, 그 함수는 **스텁(stub)**으로 대체된다.  <br>
그러나 일반적으로 웹 브라우저는 외부에서 직접 주소 지정이 불가능하므로, 이 스텁은 클라이언트를 직접 호출하지는 않는다.  <br>
대신, 서버는 항상 클라이언트 요청에 응답하는 형식으로 동작하므로 이를 활용할 수 있다.  <br>
따라서 스텁은 단순히 HTTP 응답을 통해 서버에서 클라이언트로의 호출을 나타내며,  <br>
함께 서버의 continuation을 전달하여 해당 호출이 완료되었을 때 재개(resume)할 수 있게 한다. <br>

이 방식으로 반환이 이루어지면, Links 프로그램의 모든 상태는 클라이언트에 존재하므로, 서버는 아무 것도 저장하지 않아도 된다. <br>

클라이언트가 **서버→클라이언트 호출(server-to-client call)**을 완료하면,  <br>
새 HTTP 요청을 서버로 보내면서 결과 값과 서버 continuation을 전달한다.  <br>
서버는 이 continuation을 적용(apply)함으로써 계산을 다시 시작한다. <br>


